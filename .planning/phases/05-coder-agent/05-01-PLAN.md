---
phase: 05-coder-agent
plan: 01
type: execute
---

<objective>
Create CoderAgent that implements code based on plans with structured output and Convex workflow integration.

Purpose: Provide a code-focused agent that receives plan steps and produces file modifications, completing the implementation capability needed for the multi-agent workflow.

Output: Working CoderAgent class with CodeResult interface, comprehensive tests, and documentation.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Auto-selected based on dependency graph (from frontmatter):
@.planning/phases/03-agent-foundation/03-01-SUMMARY.md
@.planning/phases/04-planner-agent/04-01-SUMMARY.md

# Key files from frontmatter (relevant to this phase):
@src/agents/BaseAgent.ts
@src/agents/PlannerAgent.ts
@src/types/plan.ts
@src/types/agent.ts

**Tech stack available:** [@anthropic-ai/claude-agent-sdk, Convex helper functions pattern, abstract BaseAgent with hooks, public API with v.* validators]
**Established patterns:** [BaseAgent extension pattern (getSystemPrompt only), domain-specific execute methods (executePlan), hooks for session tracking, separation of concerns]
**Constraining decisions:**
- [Phase 03-01]: Abstract BaseAgent class with protected Convex integration methods (SDK + Convex pattern)
- [Phase 03-01]: SessionStart/SessionEnd hooks for automatic state persistence (manual trigger pattern)
- [Phase 03-01]: Subclasses implement only getSystemPrompt() - BaseAgent handles all Convex details
- [Phase 04-01]: Use domain-specific execute method (executePlan vs execute) to avoid BaseAgent signature conflict

**Issues being addressed:** None

**Concerns being verified:** None
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define CodeResult and FileChange interfaces</name>
  <files>src/types/code.ts</files>
  <action>Create CodeResult interface in src/types/code.ts with:
- FileChange interface: path (string), content (string), operation ('create' | 'update' | 'delete')
- CodeResult interface: changes (FileChange[]), summary (string), filesModified (string[])
- Add helper function validateCodeResult() that checks: changes array exists, 1-10 items max, each change has path, content, valid operation, no duplicate paths
- Export types from src/types/index.ts if it exists, otherwise export directly from code.ts
Follow pattern from src/types/plan.ts (PlanResult interface with similar validation)</action>
  <verify>TypeScript compilation passes, can import { CodeResult, FileChange, validateCodeResult } from src/types/code.js</verify>
  <done>CodeResult interface defined with validation helper, all TypeScript compilation succeeds</done>
</task>

<task type="auto">
  <name>Task 2: Create CoderAgent class extending BaseAgent</name>
  <files>src/agents/CoderAgent.ts</files>
  <action>Create CoderAgent class in src/agents/CoderAgent.ts:
- Extend BaseAgent (follow PlannerAgent pattern from Phase 4)
- Implement getSystemPrompt() returning prompt focused on code implementation: "You are a coding assistant. Implement code changes based on plan steps. Always output structured JSON with FileChange arrays."
- Add executeCode() method (not execute() to avoid BaseAgent signature conflict):
  - Accepts prompt string, optional CodeOptions { maxChanges?: number, allowedPaths?: string[] }
  - Calls BaseAgent.execute() internally
  - Returns Promise<CodeResult>
  - Uses parseCodeResult() to extract JSON from markdown code blocks (same pattern as PlannerAgent.parsePlanResult())
  - Validates result using validateCodeResult()
  - Throws error if validation fails
- Add parseCodeResult() private method: extracts JSON from ```json blocks or plain text, handles parse errors
- Add validateCodeResult() private method: uses validation helper from types/code.ts
- Add executeWithWorkflow() for Convex workflow integration (same pattern as PlannerAgent)
Follow exact pattern from PlannerAgent.ts but with code-focused prompts and CodeResult type</action>
  <verify>TypeScript compilation passes, can import { CoderAgent } from src/agents/index.js</verify>
  <done>CoderAgent class created with executeCode(), parseCodeResult(), validateCodeResult(), executeWithWorkflow() methods</done>
</task>

<task type="auto">
  <name>Task 3: Export CoderAgent and create comprehensive tests</name>
  <files>src/agents/index.ts, tests/coder.test.ts</files>
  <action>
1. Update src/agents/index.ts:
   - Export CoderAgent class
   - Export CoderConfig type (extends AgentConfig with maxChanges, allowedPaths)

2. Create tests/coder.test.ts with comprehensive tests (follow pattern from tests/planner.test.ts):
   - Mock SDK calls to avoid real API usage (same pattern as planner.test.ts)
   - Tests for instantiation (config, agentType, workflowId, model)
   - Tests for system prompt content (checks for "code implementation", "FileChange arrays")
   - Tests for executeCode() parsing JSON from markdown blocks
   - Tests for executeCode() parsing JSON from plain text
   - Tests for validateCodeResult() accepting valid changes
   - Tests for validateCodeResult() rejecting invalid operations
   - Tests for validateCodeResult() rejecting duplicate paths
   - Tests for validateCodeResult() enforcing 1-10 changes limit
   - Tests for executeWithWorkflow() with workflowId
   - Mock Convex client for workflow tests
   - Total: ~30-35 tests covering all code paths

Use vi.mock() for @anthropic-ai/claude-agent-sdk and convex client (same as planner.test.ts)
</action>
  <verify>npm test passes for coder.test.ts, all tests pass, no TypeScript errors</verify>
  <done>30-35 tests created covering instantiation, parsing, validation, workflow integration, all passing</done>
</task>

<task type="auto">
  <name>Task 4: Document CoderAgent usage in README</name>
  <files>src/agents/README.md</files>
  <action>Update src/agents/README.md:
- Add CoderAgent section after PlannerAgent
- Document CoderConfig options (maxChanges, allowedPaths)
- Show usage example: const coder = new CoderAgent({ agentType: "coder" })
- Show executeCode() usage with plan step input
- Show CodeResult structure (changes, summary, filesModified)
- Show FileChange structure (path, content, operation)
- Show workflow integration example with executeWithWorkflow()
- Add comparison table: PlannerAgent (task decomposition) vs CoderAgent (code implementation) vs ReviewerAgent (validation)
Follow same format as PlannerAgent documentation in current README
</action>
  <verify>README.md includes CoderAgent section with examples, compiles without errors</verify>
  <done>README.md updated with CoderAgent documentation following PlannerAgent pattern</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm test` passes all tests (existing + new coder tests)
- [ ] No TypeScript errors
- [ ] CoderAgent can be imported from src/agents/index.js
- [ ] CodeResult types can be imported from src/types/code.js
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- CoderAgent follows same patterns as PlannerAgent
- Tests cover all code paths
  </success_criteria>

<output>
After completion, create `.planning/phases/05-coder-agent/05-01-SUMMARY.md`:

# Phase 5 Plan 1: Coder Agent Summary

**[Substantive one-liner - what shipped, not "phase complete"]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.ts` - Description
- `path/to/another.ts` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Phase 5 complete. Ready for Phase 6: Reviewer Agent.
</output>
