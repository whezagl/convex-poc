---
phase: 14-template-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/template-engine/package.json
  - packages/template-engine/src/engine/handlebars.ts
  - packages/template-engine/src/engine/helpers.ts
  - packages/template-engine/src/engine/escaper.ts
  - packages/template-engine/src/engine/index.ts
  - packages/template-engine/src/generator/formatter.ts
  - packages/template-engine/src/generator/index.ts
  - packages/template-engine/src/watcher/template-watcher.ts
  - packages/template-engine/src/index.ts
  - packages/template-engine/tsconfig.json
autonomous: true

must_haves:
  truths:
    - "Developer can import TemplateEngine from @convex-poc/template-engine"
    - "Template engine renders .handlebars files with variable substitution"
    - "HTML and SQL escaping is applied by default to prevent XSS and SQL injection"
    - "Custom Handlebars helpers (pascalCase, camelCase, isRequired) are registered"
    - "Template changes hot-reload without restarting the application in development mode"
    - "Generated code is formatted with Biome"
  artifacts:
    - path: "packages/template-engine/src/engine/handlebars.ts"
      provides: "Handlebars engine setup with custom helpers"
      exports: ["createTemplateEngine"]
    - path: "packages/template-engine/src/engine/helpers.ts"
      provides: "Custom Handlebars helpers (pascalCase, camelCase, isRequired)"
      exports: ["registerHelpers"]
    - path: "packages/template-engine/src/generator/formatter.ts"
      provides: "Biome formatter integration"
      exports: ["formatCode"]
    - path: "packages/template-engine/src/watcher/template-watcher.ts"
      provides: "Hot-reload file watching with chokidar"
      exports: ["watchTemplates"]
    - path: "packages/template-engine/package.json"
      provides: "Package exports and dependencies"
      contains: "handlebars, @biomejs/js-api, chokidar"
  key_links:
    - from: "packages/template-engine/src/engine/handlebars.ts"
      to: "handlebars npm package"
      via: "import Handlebars from 'handlebars'"
      pattern: "Handlebars\\.create"
    - from: "packages/template-engine/src/generator/formatter.ts"
      to: "@biomejs/js-api"
      via: "import { format } from '@biomejs/js-api'"
      pattern: "format\\("
    - from: "packages/template-engine/src/watcher/template-watcher.ts"
      to: "chokidar npm package"
      via: "import chokidar from 'chokidar'"
      pattern: "chokidar\\.watch"
---

<objective>
Build @repo/template-engine package with Handlebars integration, custom helpers, Biome formatting, and hot-reload file watching.

Purpose: This is the foundational template engine that all template rendering operations depend on. It provides secure template rendering with proper escaping, code formatting, and development workflow support.
Output: Working template engine package ready for DDL parser integration and template creation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/14-template-system/14-CONTEXT.md
@.planning/phases/14-template-system/14-RESEARCH.md
@.planning/phases/13-foundation/13-02-SUMMARY.md

@packages/template-engine/package.json
</context>

<tasks>

<task type="auto">
  <name>Set up template-engine package structure</name>
  <files>packages/template-engine/package.json, packages/template-engine/tsconfig.json, packages/template-engine/src/index.ts</files>
  <action>
    Initialize @convex-poc/template-engine package:

    1. Update `packages/template-engine/package.json`:
    ```json
    {
      "name": "@convex-poc/template-engine",
      "version": "0.1.0",
      "type": "module",
      "private": true,
      "exports": {
        "./engine": "./src/engine/index.js",
        "./generator": "./src/generator/index.js",
        "./watcher": "./src/watcher/index.js"
      },
      "scripts": {
        "build": "tsc",
        "dev": "tsc --watch",
        "test": "vitest run"
      },
      "dependencies": {
        "handlebars": "^4.7.8"
      },
      "devDependencies": {
        "@biomejs/js-api": "^4.0.0",
        "@types/handlebars": "^4.7.0",
        "chokidar": "^4.0.0",
        "typescript": "workspace:*",
        "@types/node": "workspace:*",
        "vitest": "workspace:*"
      }
    }
    ```

    2. Create `packages/template-engine/tsconfig.json`:
    ```json
    {
      "extends": "../../tsconfig.json",
      "compilerOptions": {
        "composite": true,
        "outDir": "./dist",
        "rootDir": "./src"
      },
      "include": ["src/**/*"],
      "exclude": ["node_modules", "dist"]
      }
    }
    ```

    3. Create `packages/template-engine/src/index.ts`:
    ```typescript
    // Re-export main entry points
    export { createTemplateEngine, TemplateEngine } from './engine/index.js';
    export { generateCode, formatCode } from './generator/index.js';
    export { watchTemplates } from './watcher/index.js';
    ```

    Run `pnpm install` to install dependencies.
  </action>
  <verify>
    - `pnpm install` succeeds without errors
    - `pnpm list --depth 0` in packages/template-engine shows handlebars, @biomejs/js-api, chokidar
    - `ls -la packages/template-engine/src/` shows index.ts created
  </verify>
  <done>
    Package structure is initialized with all dependencies installed
  </done>
</task>

<task type="auto">
  <name>Create Handlebars engine with custom helpers</name>
  <files>packages/template-engine/src/engine/handlebars.ts, packages/template-engine/src/engine/helpers.ts, packages/template-engine/src/engine/escaper.ts, packages/template-engine/src/engine/index.ts</files>
  <action>
    Build Handlebars template engine with custom helpers and security:

    1. Create `packages/template-engine/src/engine/helpers.ts`:
    ```typescript
    import Handlebars from 'handlebars';

    /**
     * Register custom Handlebars helpers for template rendering
     */
    export function registerHelpers(engine: Handlebars): void {
      // PascalCase transformation for TypeScript types
      engine.registerHelper('pascalCase', (str: string) => {
        if (!str) return '';
        return str
          .replace(/[-_\s]+(.)?/g, (_, c) => (c ? c.toUpperCase() : ''))
          .replace(/^(.)/, (_, c) => c.toUpperCase());
      });

      // camelCase transformation for variables
      engine.registerHelper('camelCase', (str: string) => {
        if (!str) return '';
        return str
          .replace(/[-_\s]+(.)?/g, (_, c) => (c ? c.toUpperCase() : ''))
          .replace(/^(.)/, (_, c) => c.toLowerCase());
      });

      // Check if column is required (not null, no default)
      engine.registerHelper('isRequired', (column: any) => {
        return !column.nullable && !column.defaultValue;
      });

      // Generate TypeScript type from PostgreSQL type
      engine.registerHelper('typescriptType', (column: any) => {
        const typeMap: Record<string, string> = {
          uuid: 'string',
          text: 'string',
          varchar: 'string',
          integer: 'number',
          bigint: 'number',
          boolean: 'boolean',
          timestamp: 'Date',
          timestamptz: 'Date',
          jsonb: 'Record<string, unknown>',
          json: 'Record<string, unknown>',
          decimal: 'number',
          'double precision': 'number',
        };

        if (column.isArray) {
          return `${typeMap[column.type] || 'unknown'}[]`;
        }

        return typeMap[column.type] || 'unknown';
      });

      // Format date for file headers
      engine.registerHelper('formatDate', (date: Date) => {
        return date.toISOString().split('T')[0];
      });

      // Conditional rendering helper
      engine.registerHelper('eq', (a: any, b: any) => a === b);
      engine.registerHelper('ne', (a: any, b: any) => a !== b);
      engine.registerHelper('gt', (a: number, b: number) => a > b);
      engine.registerHelper('lt', (a: number, b: number) => a < b);
    }
    ```

    2. Create `packages/template-engine/src/engine/escaper.ts`:
    ```typescript
    /**
     * Escaping utilities for template security
     * Note: Handlebars already HTML-escapes by default with {{var}}
     * This module provides additional escaping for SQL and special contexts
     */

    /**
     * Escape SQL identifiers (table names, column names)
     * Uses double quotes as per PostgreSQL standard
     */
    export function escapeSqlIdentifier(identifier: string): string {
      // Escape double quotes by doubling them: "my""table"
      return `"${identifier.replace(/"/g, '""')}"`;
    }

    /**
     * Escape SQL string literals
     * Uses single quotes with proper escaping
     */
    export function escapeSqlString(str: string): string {
      // Escape single quotes by doubling them: 'O''Reilly'
      return `'${str.replace(/'/g, "''")}'`;
    }

    /**
     * Validate PostgreSQL identifier
     * Prevents SQL injection in dynamic SQL
     */
    export function isValidIdentifier(identifier: string): boolean {
      // PostgreSQL identifiers: letters, digits, underscores, not starting with digit
      return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(identifier);
    }

    /**
     * Sanitize template variable names
     * Prevents template injection attacks
     */
    export function sanitizeVariableName(name: string): string {
      // Remove any characters that aren't valid in JavaScript identifiers
      return name.replace(/[^a-zA-Z0-9_$]/g, '');
    }
    ```

    3. Create `packages/template-engine/src/engine/handlebars.ts`:
    ```typescript
    import Handlebars from 'handlebars';
    import { registerHelpers } from './helpers.js';

    export interface TemplateEngine {
      compile(template: string): HandlebarsTemplateDelegate;
      render(template: string, context: Record<string, unknown>): string;
      load(templatePath: string): HandlebarsTemplateDelegate;
    }

    /**
     * Create a configured Handlebars template engine
     * HTML escaping is ON by default (use {{{var}}} only for trusted content)
     */
    export function createTemplateEngine(): TemplateEngine {
      const engine = Handlebars.create();

      // Register custom helpers
      registerHelpers(engine);

      // Store loaded templates for hot-reload
      const templateCache = new Map<string, HandlebarsTemplateDelegate>();

      return {
        compile(template: string): HandlebarsTemplateDelegate {
          return engine.compile(template);
        },

        render(template: string, context: Record<string, unknown>): string {
          const compiled = engine.compile(template);
          return compiled(context);
        },

        load(templatePath: string): HandlebarsTemplateDelegate {
          // Templates will be loaded by file system in watcher
          // This is a placeholder for the loader interface
          throw new Error('Template loading requires file system access - use watcher module');
        },
      };
    }

    // Re-export Handlebars types for convenience
    export type { HandlebarsTemplateDelegate } from 'handlebars';
    ```

    4. Create `packages/template-engine/src/engine/index.ts`:
    ```typescript
    export { createTemplateEngine, TemplateEngine } from './handlebars.js';
    export { registerHelpers } from './helpers.js';
    export {
      escapeSqlIdentifier,
      escapeSqlString,
      isValidIdentifier,
      sanitizeVariableName,
    } from './escaper.js';
    ```
  </action>
  <verify>
    - `cd packages/template-engine && pnpm exec tsc --noEmit` compiles without errors
    - Helpers are properly typed with TypeScript
    - Escaper functions handle edge cases (empty strings, special characters)
  </verify>
  <done>
    Handlebars engine is created with custom helpers and security utilities
  </done>
</task>

<task type="auto">
  <name>Implement Biome formatter integration</name>
  <files>packages/template-engine/src/generator/formatter.ts, packages/template-engine/src/generator/index.ts</files>
  <action>
    Create code generator with Biome formatting:

    1. Create `packages/template-engine/src/generator/formatter.ts`:
    ```typescript
    import { format } from '@biomejs/js-api';

    export interface FormatOptions {
      filePath: string;
      lineWidth?: number;
      indentStyle?: 'space' | 'tab';
      indentWidth?: number;
    }

    /**
     * Format generated code using Biome
     * Biome is 20x faster than Prettier with 97% compatibility
     */
    export async function formatCode(
      code: string,
      options: FormatOptions
    ): Promise<string> {
      try {
        const formatted = await format(code, {
          filePath: options.filePath,
          lineWidth: options.lineWidth ?? 80,
          indentStyle: options.indentStyle ?? 'space',
          indentWidth: options.indentWidth ?? 2,
        });

        return formatted;
      } catch (error) {
        // If formatting fails, return original code
        // This allows development to continue even if Biome has issues
        console.warn(`Biome formatting failed for ${options.filePath}:`, error);
        return code;
      }
    }

    /**
     * Format code synchronously (fallback for simpler cases)
     * Note: Biome's async API is preferred, but this provides a sync option
     */
    export function formatCodeSync(code: string, filePath: string): string {
      // Basic synchronous formatting as fallback
      // In production, use async formatCode for better performance
      return code; // Biome doesn't have a sync API, so we return as-is
    }
    ```

    2. Create `packages/template-engine/src/generator/index.ts`:
    ```typescript
    export { formatCode, formatCodeSync, type FormatOptions } from './formatter.js';
    ```
  </action>
  <verify>
    - `cd packages/template-engine && pnpm exec tsc --noEmit` compiles without errors
    - Biome is properly imported from @biomejs/js-api
    - Error handling gracefully falls back to unformatted code
  </verify>
  <done>
    Biome formatter integration is ready for code generation
  </done>
</task>

<task type="auto">
  <name>Implement hot-reload template watcher</name>
  <files>packages/template-engine/src/watcher/template-watcher.ts, packages/template-engine/src/watcher/index.ts</files>
  <action>
    Create file watcher for template hot-reload with chokidar:

    1. Create `packages/template-engine/src/watcher/template-watcher.ts`:
    ```typescript
    import chokidar from 'chokidar';
    import { promises as fs } from 'fs';
    import { join } from 'path';

    export interface WatcherOptions {
      templateDir: string;
      onTemplateChange?: (templatePath: string) => void;
      onTemplateAdd?: (templatePath: string) => void;
      onTemplateUnlink?: (templatePath: string) => void;
      onError?: (error: Error) => void;
    }

    export interface TemplateWatcher {
      close(): Promise<void>;
      ready: Promise<void>;
    }

    /**
     * Watch template files for changes and trigger hot-reload
     * Uses chokidar for cross-platform file watching
     */
    export function watchTemplates(options: WatcherOptions): TemplateWatcher {
      const {
        templateDir,
        onTemplateChange,
        onTemplateAdd,
        onTemplateUnlink,
        onError,
      } = options;

      // Create watcher with configuration
      const watcher = chokidar.watch(join(templateDir, '**/*.hbs'), {
        persistent: true,
        ignoreInitial: true, // Don't fire on initial scan
        awaitWriteFinish: {
          stabilityThreshold: 100, // Wait 100ms after write
          pollInterval: 10,
        },
        ignorePermissionErrors: true,
      });

      // Handle file changes
      watcher.on('change', (filePath) => {
        console.log(`[TemplateWatcher] Template changed: ${filePath}`);
        onTemplateChange?.(filePath);
      });

      // Handle new templates
      watcher.on('add', (filePath) => {
        console.log(`[TemplateWatcher] Template added: ${filePath}`);
        onTemplateAdd?.(filePath);
      });

      // Handle deleted templates
      watcher.on('unlink', (filePath) => {
        console.log(`[TemplateWatcher] Template deleted: ${filePath}`);
        onTemplateUnlink?.(filePath);
      });

      // Handle errors
      watcher.on('error', (error) => {
        console.error('[TemplateWatcher] Watcher error:', error);
        onError?.(error);
      });

      // Return watcher interface
      return {
        async close(): Promise<void> {
          await watcher.close();
        },
        ready: new Promise((resolve, reject) => {
          watcher.on('ready', () => resolve());
          watcher.on('error', reject);
        }),
      };
    }

    /**
     * Load template file content
     */
    export async function loadTemplate(templatePath: string): Promise<string> {
      try {
        return await fs.readFile(templatePath, 'utf-8');
      } catch (error) {
        throw new Error(`Failed to load template ${templatePath}: ${error}`);
      }
    }

    /**
     * List all template files in directory
     */
    export async function listTemplates(templateDir: string): Promise<string[]> {
      const { readdir } = await import('fs/promises');
      const { join } = await import('path');

      async function walk(dir: string): Promise<string[]> {
        const files = await readdir(dir, { withFileTypes: true });
        const paths: string[] = [];

        for (const file of files) {
          const path = join(dir, file.name);
          if (file.isDirectory()) {
            paths.push(...(await walk(path)));
          } else if (file.name.endsWith('.hbs')) {
            paths.push(path);
          }
        }

        return paths;
      }

      return walk(templateDir);
    }
    ```

    2. Create `packages/template-engine/src/watcher/index.ts`:
    ```typescript
    export {
      watchTemplates,
      loadTemplate,
      listTemplates,
      type WatcherOptions,
      type TemplateWatcher,
    } from './template-watcher.js';
    ```
  </action>
  <verify>
    - `cd packages/template-engine && pnpm exec tsc --noEmit` compiles without errors
    - Chokidar is properly imported and configured
    - File watching uses proper async patterns and error handling
  </verify>
  <done>
    Template hot-reload watcher is implemented and ready for use
  </done>
</task>

</tasks>

<verification>
Overall phase checks:
- `cd packages/template-engine && pnpm exec tsc --noEmit` compiles without errors
- `pnpm install` in template-engine succeeds
- All exports are properly defined in package.json
- Custom helpers (pascalCase, camelCase, isRequired, typescriptType) are registered
- Biome formatter integration handles errors gracefully
- Chokidar watcher is configured with proper stability threshold
- HTML and SQL escaping utilities follow security best practices
</verification>

<success_criteria>
1. @convex-poc/template-engine package builds successfully
2. createTemplateEngine() returns configured Handlebars instance
3. Custom helpers transform strings correctly (pascalCase, camelCase)
4. formatCode() applies Biome formatting to generated code
5. watchTemplates() detects file changes with proper debouncing
6. Escaping utilities prevent XSS and SQL injection
</success_criteria>

<output>
After completion, create `.planning/phases/14-template-system/14-01-SUMMARY.md`
</output>
