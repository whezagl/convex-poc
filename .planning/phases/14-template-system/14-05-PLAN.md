---
phase: 14-template-system
plan: 05
type: execute
wave: 3
depends_on: [14-01, 14-02, 14-03]
files_modified:
  - .templates/crud/be/index.ts.hbs
  - .templates/crud/be/sql.ts.hbs
  - .templates/crud/be/types.ts.hbs
  - .templates/crud/be/README.md.hbs
  - .templates/crud/be/index.http.hbs
autonomous: true

must_haves:
  truths:
    - "Backend CRUD templates exist in .templates/crud/be/"
    - "Templates generate index.ts (exports), sql.ts (queries), types.ts (TypeScript types)"
    - "Templates generate README.md (documentation) and index.http (HTTP test files)"
    - "Templates use DDL parser output (TableDefinition) for context"
    - "Generated SQL uses parameterized queries ($1, $2) for SQL injection prevention"
    - "Generated code includes JSDoc comments from column descriptions"
  artifacts:
    - path: ".templates/crud/be/index.ts.hbs"
      provides: "Backend CRUD exports template"
      min_lines: 20
    - path: ".templates/crud/be/sql.ts.hbs"
      provides: "SQL query template with parameterized queries"
      min_lines: 40
    - path: ".templates/crud/be/types.ts.hbs"
      provides: "TypeScript type definitions template"
      min_lines: 30
    - path: ".templates/crud/be/README.md.hbs"
      provides: "Backend CRUD documentation template"
      min_lines: 50
    - path: ".templates/crud/be/index.http.hbs"
      provides: "HTTP test file template for REST Client"
      min_lines: 30
  key_links:
    - from: ".templates/crud/be/*.hbs"
      to: "DDL parser output"
      via: "TableDefinition context"
      pattern: "\\{\\{#each columns\\}\\}\\{\\{/each\\}\\}"
    - from: ".templates/crud/be/sql.ts.hbs"
      to: "PostgreSQL database"
      via: "parameterized queries"
      pattern: "\\$\\d+"
---

<objective>
Create backend CRUD templates (index.ts, sql.ts, types.ts, README.md, index.http) for generating database access code from DDL parser output.

Purpose: These templates generate complete CRUD operations (Create, Read, Update, Delete) for any database table. They use parameterized queries for security and include JSDoc documentation.
Output: Handlebars templates in .templates/crud/be/ that render to production-ready backend CRUD code.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/14-template-system/14-CONTEXT.md
@.planning/phases/14-template-system/14-RESEARCH.md
@.planning/phases/14-template-system/14-01-SUMMARY.md
@.planning/phases/14-template-system/14-02-SUMMARY.md
@.planning/phases/14-template-system/14-03-SUMMARY.md

@packages/template-engine/src/parser/index.ts
</context>

<tasks>

<task type="auto">
  <name>Create backend CRUD types template</name>
  <files>.templates/crud/be/types.ts.hbs</files>
  <action>
    Create Handlebars template for TypeScript type definitions:

    Create `.templates/crud/be/types.ts.hbs`:
    ```handlebars
/**
 * {{pascalCase tableName}} Types
 *
 * ⚠️ DO NOT EDIT — Auto-generated on {{formatDate (new Date)}}
 *
 * Database: {{databaseName}}
 * Table: {{tableName}}
 */

/**
 * {{pascalCase tableName}} database record
 */
export interface {{pascalCase tableName}} {
{{#each columns}}
  /**
   * {{#if (isRequired this)}}Required{{else}}Optional{{endif}} {{name}}
   * Type: {{type}}
{{#if comment}}
   * Description: {{{comment}}}
{{/if}}
   */
  {{name}}: {{#if (isRequired this)}}{{typescriptType this}}{{else}}{{typescriptType this}} | null{{/if}};
{{/each}}
}

/**
 * Create {{pascalCase tableName}} input (all fields optional)
 */
export interface Create{{pascalCase tableName}}Input {
{{#each columns}}
  {{name}}?: {{typescriptType this}};
{{/each}}
}

/**
 * Update {{pascalCase tableName}} input (all fields optional)
 */
export interface Update{{pascalCase tableName}}Input {
{{#each columns}}
  {{name}}?: {{typescriptType this}};
{{/each}}
}

/**
 * {{pascalCase tableName}} query filters
 */
export interface {{pascalCase tableName}}Where {
  id?: string;
{{#each columns}}
  {{#unless isPrimaryKey}}
  {{name}}?: {{#if (eq (typescriptType this) 'string')}}string | string[]{{else}}{{typescriptType this}}{{/if}};
  {{/unless}}
{{/each}}
}

/**
 * {{pascalCase tableName}} query options
 */
export interface {{pascalCase tableName}}QueryOptions {
  limit?: number;
  offset?: number;
  orderBy?: keyof {{pascalCase tableName}};
  orderDirection?: 'ASC' | 'DESC';
}
    ```

    Template context variables:
    - `tableName`: Table name (snake_case from database)
    - `databaseName`: Database name
    - `columns`: Array of column definitions from DDL parser
    - `pascalCase`: Transform table name to PascalCase (e.g., student_records → StudentRecords)
    - `typescriptType`: Helper to map PostgreSQL types to TypeScript types
    - `isRequired`: Helper to check if column is required (not null, no default)
    - `formatDate`: Current date for file header

    Each template file follows the auto-generated warning pattern.
  </action>
  <verify>
    - Template file exists at .templates/crud/be/types.ts.hbs
    - Uses {{pascalCase tableName}} for type names
    - Generates Create, Update, Where, and QueryOptions interfaces
    - Includes JSDoc comments for each field
    - Uses typescriptType helper for type mapping
  </verify>
  <done>
    Backend CRUD types template is created with JSDoc documentation
  </done>
</task>

<task type="auto">
  <name>Create backend CRUD SQL queries template</name>
  <files>.templates/crud/be/sql.ts.hbs</files>
  <action>
    Create Handlebars template for SQL queries with parameterization:

    Create `.templates/crud/be/sql.ts.hbs`:
    ```handlebars
/**
 * {{pascalCase tableName}} SQL Queries
 *
 * ⚠️ DO NOT EDIT — Auto-generated on {{formatDate (new Date)}}
 *
 * Database: {{databaseName}}
 * Table: {{tableName}}
 *
 * All queries use parameterized statements to prevent SQL injection.
 * Never interpolate user input directly into SQL strings.
 */

import { {{pascalCase tableName}}, Create{{pascalCase tableName}}Input, Update{{pascalCase tableName}}Input, {{pascalCase tableName}}Where } from './types.js';

/**
 * SQL query templates for {{pascalCase tableName}}
 */
export const {{camelCase tableName}}Queries = {
  /**
   * Select all {{camelCase tableName}} records
   */
  SELECT_ALL: `
    SELECT *
    FROM "{{tableName}}"
    ORDER BY {{#each (filterColumns columns 'isPrimaryKey')}}{{#if @first}}{{name}}{{else}}, {{name}}{{/if}}{{/each}}
  `,

  /**
   * Select {{camelCase tableName}} by ID
   */
  SELECT_BY_ID: `
    SELECT *
    FROM "{{tableName}}"
    WHERE "{{#findColumn columns 'isPrimaryKey'}}{{name}}{{/findColumn}}" = $1
  `,

  /**
   * Insert new {{camelCase tableName}}
   */
  INSERT: `
    INSERT INTO "{{tableName}}" (
      {{#each (filterColumns columns 'isPrimaryKey')}}
      "{{name}}"{{#unless @last}}, {{/unless}}
      {{/each}}
    )
    VALUES (
      {{#each (filterColumns columns 'isPrimaryKey'}}
      ${{add @index 1}}{{#unless @last}}, {{/unless}}
      {{/each}}
    )
    RETURNING *
  `,

  /**
   * Update {{camelCase tableName}} by ID
   */
  UPDATE: `
    UPDATE "{{tableName}}"
    SET
      {{#each (filterColumns columns 'isPrimaryKey')}}
      "{{name}}" = ${{add (filterColumns (filterColumns columns 'isPrimaryKey') 'isPrimaryKey').length 1}}{{#unless @last}}, {{/unless}}
      {{/each}}
    WHERE "{{#findColumn columns 'isPrimaryKey'}}{{name}}{{/findColumn}}" = $1
    RETURNING *
  `,

  /**
   * Delete {{camelCase tableName}} by ID
   */
  DELETE: `
    DELETE FROM "{{tableName}}"
    WHERE "{{#findColumn columns 'isPrimaryKey'}}{{name}}{{/findColumn}}" = $1
    RETURNING *
  `,

  /**
   * Select {{camelCase tableName}} with filters
   */
  SELECT_WHERE: (filters: string[]) => {
    const whereClause = filters.map((f, i) => `"${f}" = $${i + 1}`).join(' AND ');
    return `
      SELECT *
      FROM "{{tableName}}"
      ${filters.length ? `WHERE ${whereClause}` : ''}
      ORDER BY "{{#findColumn columns 'isPrimaryKey'}}{{name}}{{/findColumn}}" DESC
      LIMIT $${filters.length + 1} OFFSET $${filters.length + 2}
    `;
  },
};

/**
 * Parameter builders for {{pascalCase tableName}} queries
 */
export const {{camelCase tableName}}Params = {
  /**
   * Build insert parameters from input
   */
  buildInsertParams: (input: Create{{pascalCase tableName}}Input): any[] => {
    return [
{{#each (filterColumns columns 'isPrimaryKey')}}
      input.{{camelCase name}},
{{/each}}
    ].filter(p => p !== undefined);
  },

  /**
   * Build update parameters from input and ID
   */
  buildUpdateParams: (id: string, input: Update{{pascalCase tableName}}Input): any[] => {
    return [
      id,
{{#each (filterColumns columns 'isPrimaryKey')}}
      input.{{camelCase name}},
{{/each}}
    ].filter(p => p !== undefined);
  },
};
    ```

    Key security features:
    - Uses `$1, $2, $3` parameter placeholders (PostgreSQL syntax)
    - Never interpolates column names or values directly
    - All user input goes through parameter array
    - Includes JSDoc warnings about SQL injection prevention

    Template helpers:
    - `filterColumns`: Filter columns by condition
    - `findColumn`: Find first column matching condition
    - `add`: Math addition for parameter indices
    - `camelCase`: Transform to camelCase
    - `pascalCase`: Transform to PascalCase
  </action>
  <verify>
    - Template file exists at .templates/crud/be/sql.ts.hbs
    - Uses parameterized queries ($1, $2, $3) for all user input
    - Includes JSDoc warning about SQL injection prevention
    - Generates SELECT, INSERT, UPDATE, DELETE queries
    - Parameter builders extract values from input objects
  </verify>
  <done>
    Backend CRUD SQL queries template is created with parameterization for security
  </done>
</task>

<task type="auto">
  <name>Create backend CRUD index template</name>
  <files>.templates/crud/be/index.ts.hbs</files>
  <action>
    Create Handlebars template for CRUD function exports:

    Create `.templates/crud/be/index.ts.hbs`:
    ```handlebars
/**
 * {{pascalCase tableName}} CRUD Functions
 *
 * ⚠️ DO NOT EDIT — Auto-generated on {{formatDate (new Date)}}
 *
 * Database: {{databaseName}}
 * Table: {{tableName}}
 */

import type { Pool, PoolClient } from 'pg';
import type {
  {{pascalCase tableName}},
  Create{{pascalCase tableName}}Input,
  Update{{pascalCase tableName}}Input,
  {{pascalCase tableName}}Where,
  {{pascalCase tableName}}QueryOptions,
} from './types.js';
import { {{camelCase tableName}}Queries, {{camelCase tableName}}Params } from './sql.js';

/**
 * {{pascalCase tableName}} CRUD operations
 */
export class {{pascalCase tableName}}Repository {
  constructor(private db: Pool | PoolClient) {}

  /**
   * Find all {{camelCase tableName}} records
   */
  async findMany(
    where?: {{pascalCase tableName}}Where,
    options?: {{pascalCase tableName}}QueryOptions
  ): Promise<{{pascalCase tableName}}[]> {
    const filters = where ? Object.keys(where) : [];
    const query = {{camelCase tableName}}Queries.SELECT_WHERE(filters);

    const params = [
      ...(where ? Object.values(where) : []),
      options?.limit ?? 100,
      options?.offset ?? 0,
    ];

    const result = await this.db.query(query, params);
    return result.rows;
  }

  /**
   * Find {{camelCase tableName}} by ID
   */
  async findById(id: string): Promise<{{pascalCase tableName}} | null> {
    const result = await this.db.query({{camelCase tableName}}Queries.SELECT_BY_ID, [id]);
    return result.rows[0] || null;
  }

  /**
   * Create new {{camelCase tableName}}
   */
  async create(input: Create{{pascalCase tableName}}Input): Promise<{{pascalCase tableName}}> {
    const params = {{camelCase tableName}}Params.buildInsertParams(input);
    const result = await this.db.query({{camelCase tableName}}Queries.INSERT, params);
    return result.rows[0];
  }

  /**
   * Update {{camelCase tableName}} by ID
   */
  async update(id: string, input: Update{{pascalCase tableName}}Input): Promise<{{pascalCase tableName}} | null> {
    const params = {{camelCase tableName}}Params.buildUpdateParams(id, input);
    const result = await this.db.query({{camelCase tableName}}Queries.UPDATE, params);
    return result.rows[0] || null;
  }

  /**
   * Delete {{camelCase tableName}} by ID
   */
  async delete(id: string): Promise<{{pascalCase tableName}} | null> {
    const result = await this.db.query({{camelCase tableName}}Queries.DELETE, [id]);
    return result.rows[0] || null;
  }

  /**
   * Count {{camelCase tableName}} records
   */
  async count(where?: {{pascalCase tableName}}Where): Promise<number> {
    const filters = where ? Object.keys(where) : [];
    const whereClause = filters.map((f, i) => `"${f}" = $${i + 1}`).join(' AND ');
    const query = `
      SELECT COUNT(*) as count
      FROM "{{tableName}}"
      ${filters.length ? `WHERE ${whereClause}` : ''}
    `;

    const params = where ? Object.values(where) : [];
    const result = await this.db.query(query, params);
    return parseInt(result.rows[0].count, 10);
  }
}

/**
 * Create {{pascalCase tableName}} repository instance
 */
export function create{{pascalCase tableName}}Repository(db: Pool | PoolClient) {
  return new {{pascalCase tableName}}Repository(db);
}
    ```

    Creates repository class with findMany, findById, create, update, delete, and count methods.
  </action>
  <verify>
    - Template file exists at .templates/crud/be/index.ts.hbs
    - Generates repository class with full CRUD operations
    - Uses pg Pool or PoolClient for database connections
    - Each method has JSDoc documentation
    - Factory function creates repository instances
  </verify>
  <done>
    Backend CRUD index template is created with repository class
  </done>
</task>

<task type="auto">
  <name>Create backend CRUD README and HTTP test templates</name>
  <files>.templates/crud/be/README.md.hbs, .templates/crud/be/index.http.hbs</files>
  <action>
    Create Handlebars templates for documentation and HTTP testing:

    1. Create `.templates/crud/be/README.md.hbs`:
    ```handlebars
# {{pascalCase tableName}} CRUD Module

⚠️ **DO NOT EDIT — Auto-generated on {{formatDate (new Date)}}**

Database table: `{{tableName}}`

## Overview

This module provides CRUD (Create, Read, Update, Delete) operations for the `{{tableName}}` table.

## Type Definitions

See `types.ts` for complete type definitions:

- `{{pascalCase tableName}}` - Main record type
- `Create{{pascalCase tableName}}Input` - Input for creating records
- `Update{{pascalCase tableName}}Input` - Input for updating records
- `{{pascalCase tableName}}Where` - Filter conditions
- `{{pascalCase tableName}}QueryOptions` - Query options (limit, offset, orderBy)

## Usage

```typescript
import { create{{pascalCase tableName}}Repository } from './index.js';
import type { Pool } from 'pg';

// Initialize repository
const repo = create{{pascalCase tableName}}Repository(pool);

// Find all records
const records = await repo.findMany();

// Find with filters
const filtered = await repo.findMany(
  { {{#each (takeColumns columns 3)}}{{#unless isPrimaryKey}}{{camelCase name}}: 'value',{{/unless}}{{/each}} },
  { limit: 10, offset: 0 }
);

// Find by ID
const record = await repo.findById('id');

// Create new record
const created = await repo.create({
{{#each (filterColumns columns 'isPrimaryKey')}}
  {{camelCase name}}: 'value',
{{/each}}
});

// Update record
const updated = await repo.update('id', {
  {{camelCase (findColumn columns 'name')}}: 'new value',
});

// Delete record
const deleted = await repo.delete('id');

// Count records
const count = await repo.count();
```

## Table Schema

| Column | Type | Nullable | Description |
|--------|------|----------|-------------|
{{#each columns}}
| `{{name}}` | {{type}} | {{#if nullable}}Yes{{else}}No{{/if}} | {{#if comment}}{{{comment}}}{{else}}-{{/if}} |
{{/each}}

## SQL Queries

All queries use parameterized statements to prevent SQL injection.

See `sql.ts` for:
- `{{camelCase tableName}}Queries.SELECT_ALL` - Select all records
- `{{camelCase tableName}}Queries.SELECT_BY_ID` - Select by primary key
- `{{camelCase tableName}}Queries.INSERT` - Insert new record
- `{{camelCase tableName}}Queries.UPDATE` - Update existing record
- `{{camelCase tableName}}Queries.DELETE` - Delete record
- `{{camelCase tableName}}Queries.SELECT_WHERE` - Select with filters

## Testing

Use `index.http` for REST Client testing in VS Code.
    ```

    2. Create `.templates/crud/be/index.http.hbs`:
    ```handlebars
### {{pascalCase tableName}} HTTP Tests
### ⚠️ DO NOT EDIT — Auto-generated on {{formatDate (new Date)}}

@baseUrl = http://localhost:3000/api
@tableName = {{tableName}}

### Find all {{camelCase tableName}}
GET {{baseUrl}}/{{tableName}}
Content-Type: application/json

### Find {{camelCase tableName}} by ID
@id = 1
GET {{baseUrl}}/{{tableName}}/{{id}}

### Create {{camelCase tableName}}
POST {{baseUrl}}/{{tableName}}
Content-Type: application/json

{
{{#each (filterColumns columns 'isPrimaryKey')}}
  "{{name}}": {{#if (eq (typescriptType this) 'string')}}"value"{{else}}0{{/if}}{{#unless @last}},{{/unless}}
{{/each}}
}

### Update {{camelCase tableName}}
PUT {{baseUrl}}/{{tableName}}/{{id}}
Content-Type: application/json

{
  "{{#findColumn columns 'name'}}{{name}}{{/findColumn}}": "updated value"
}

### Delete {{camelCase tableName}}
DELETE {{baseUrl}}/{{tableName}}/{{id}}

### Count {{camelCase tableName}}
GET {{baseUrl}}/{{tableName}}/count
    ```

    README documents usage, schema, and SQL queries.
    HTTP file provides REST Client tests for VS Code.
  </action>
  <verify>
    - Both template files exist
    - README.md documents all CRUD operations with code examples
    - README includes table schema with columns and types
    - index.http provides REST Client tests for all endpoints
    - HTTP file uses @baseUrl and @id variables for easy testing
  </verify>
  <done>
    Backend CRUD README and HTTP test templates are created
  </done>
</task>

</tasks>

<verification>
Overall phase checks:
- All 5 backend CRUD templates exist in .templates/crud/be/ directory
- Templates use DDL parser output (TableDefinition) for context
- Templates use Handlebars helpers (pascalCase, camelCase, typescriptType, isRequired)
- Auto-generated warnings are included in all generated files
- SQL queries use parameterized statements ($1, $2) for security
- JSDoc comments document all functions and parameters
- README.md provides usage examples and table schema
- index.http provides REST Client tests for all CRUD operations
</verification>

<success_criteria>
1. All 5 backend CRUD templates exist (index.ts, sql.ts, types.ts, README.md, index.http)
2. Templates generate complete CRUD operations (Create, Read, Update, Delete, Count)
3. SQL queries use parameterized statements ($1, $2, $3) to prevent SQL injection
4. Templates use DDL parser output (TableDefinition) for type-safe code generation
5. Generated code includes JSDoc comments documenting each function and parameter
6. README.md documents usage, table schema, and provides code examples
7. index.http provides REST Client tests for API endpoint testing
</success_criteria>

<output>
After completion, create `.planning/phases/14-template-system/14-05-SUMMARY.md`
</output>
