---
phase: 14-template-system
plan: 02
type: execute
wave: 2
depends_on: [14-01]
files_modified:
  - packages/template-engine/src/parser/pg-parser.ts
  - packages/template-engine/src/parser/types.ts
  - packages/template-engine/src/parser/validators.ts
  - packages/template-engine/src/parser/index.ts
  - packages/template-engine/package.json
autonomous: true

must_haves:
  truths:
    - "DDL parser extracts table definitions from PostgreSQL 17 DDL without using regex"
    - "Parser handles PostgreSQL 17 features (arrays, JSONB, enums, identity columns)"
    - "Foreign key relationships are extracted and exposed in parsed output"
    - "Indonesian ID validators (NISN, NIP, NUPTK) are implemented"
    - "Parser collects and reports all errors at end (continue on error)"
    - "School ERP DDL (24 tables) parses completely without errors"
  artifacts:
    - path: "packages/template-engine/src/parser/pg-parser.ts"
      provides: "PostgreSQL DDL parser using sql-parser-cst"
      exports: ["parseDDL", "extractTableDefinition"]
      min_lines: 100
    - path: "packages/template-engine/src/parser/types.ts"
      provides: "TypeScript types for parsed DDL structures"
      exports: ["TableDefinition", "Column", "ForeignKey", "Index"]
    - path: "packages/template-engine/src/parser/validators.ts"
      provides: "Indonesian national ID validators"
      exports: ["validateNISN", "validateNIP", "validateNUPTK"]
    - path: "packages/template-engine/src/parser/index.ts"
      provides: "Parser module exports"
      exports: ["parseDDL", "validateIndonesianID"]
  key_links:
    - from: "packages/template-engine/src/parser/pg-parser.ts"
      to: "sql-parser-cst npm package"
      via: "import { parse } from 'sql-parser-cst'"
      pattern: "parse\\(ddl, \\{ dialect: 'postgresql' \\}\\)"
    - from: "packages/template-engine/src/parser/validators.ts"
      to: "Indonesian ID validation rules"
      via: "Regular expressions for digit counts"
      pattern: "validateNISN|validateNIP|validateNUPTK"
---

<objective>
Implement PostgreSQL DDL parser using sql-parser-cst (not regex) with Indonesian ID validation and PostgreSQL 17 feature support.

Purpose: This parser extracts table definitions from DDL files for code generation. It must handle PostgreSQL 17 features correctly and validate Indonesian national IDs per the domain requirements.
Output: Working DDL parser that can extract table definitions, columns, foreign keys, and indexes from PostgreSQL DDL.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/14-template-system/14-CONTEXT.md
@.planning/phases/14-template-system/14-RESEARCH.md
@.planning/phases/14-template-system/14-01-SUMMARY.md
@.planning/phases/14-template-system/14-08-SUMMARY.md

@packages/template-engine/src/engine/index.ts
</context>

<tasks>

<task type="auto">
  <name>Install sql-parser-cst and define parser types</name>
  <files>packages/template-engine/package.json, packages/template-engine/src/parser/types.ts</files>
  <action>
    Install DDL parser dependency and define TypeScript types:

    1. Update `packages/template-engine/package.json`:
    Add to dependencies:
    ```json
    "sql-parser-cst": "latest"
    ```

    Add to devDependencies:
    ```json
    "@types/node": "workspace:*"
    ```

    Run `pnpm install` in packages/template-engine.

    2. Create `packages/template-engine/src/parser/types.ts`:
    ```typescript
    /**
     * Types for parsed DDL structures
     * Represents PostgreSQL schema definitions for code generation
     */

    export interface Column {
      name: string;
      type: string;
      nullable: boolean;
      defaultValue?: string;
      isPrimaryKey: boolean;
      isUnique: boolean;
      isArray: boolean;
      enumValues?: string[];
      comment?: string;
    }

    export interface ForeignKey {
      name?: string;
      columns: string[];
      referencedTable: string;
      referencedColumns: string[];
      onDelete?: 'CASCADE' | 'SET NULL' | 'SET DEFAULT' | 'RESTRICT' | 'NO ACTION';
    }

    export interface Index {
      name: string;
      columns: string[];
      isUnique: boolean;
      isPrimary: boolean;
    }

    export interface TableDefinition {
      name: string;
      columns: Column[];
      foreignKeys: ForeignKey[];
      indexes: Index[];
      comment?: string;
    }

    export interface ParseError {
      message: string;
      line?: number;
      column?: number;
      table?: string;
    }

    export interface ParseResult {
      tables: TableDefinition[];
      errors: ParseError[];
    }

    export interface IndonesianIDValidation {
      isValid: boolean;
      type: 'NISN' | 'NIP' | 'NUPTK' | 'unknown';
      errors: string[];
    }

    /**
     * PostgreSQL type to TypeScript type mapping
     */
    export const POSTGRESQL_TYPE_MAP: Record<string, string> = {
      // Integer types
      'smallint': 'number',
      'integer': 'number',
      'bigint': 'number',

      // Serial types
      'serial': 'number',
      'bigserial': 'number',

      // Floating point
      'real': 'number',
      'double precision': 'number',

      // Fixed precision
      'numeric': 'number',
      'decimal': 'number',

      // Character types
      'character varying': 'string',
      'varchar': 'string',
      'character': 'string',
      'char': 'string',
      'text': 'string',

      // Boolean
      'boolean': 'boolean',

      // Date/time
      'timestamp': 'Date',
      'timestamptz': 'Date',
      'date': 'Date',
      'time': 'string',
      'timetz': 'string',
      'interval': 'string',

      // Binary
      'bytea': 'Buffer',

      // JSON
      'json': 'Record<string, unknown>',
      'jsonb': 'Record<string, unknown>',

      // UUID
      'uuid': 'string',

      // Special
      'money': 'number',
      'xml': 'string',
    };

    /**
     * Map PostgreSQL type to TypeScript type
     */
    export function mapPostgreSQLTypeToTS(pgType: string): string {
      return POSTGRESQL_TYPE_MAP[pgType.toLowerCase()] || 'unknown';
    }
    ```
  </action>
  <verify>
    - `pnpm install` in packages/template-engine succeeds
    - sql-parser-cst is installed
    - `cd packages/template-engine && pnpm exec tsc --noEmit` compiles without errors
  </verify>
  <done>
    Parser dependencies are installed and types are defined
  </done>
</task>

<task type="auto">
  <name>Implement PostgreSQL DDL parser with sql-parser-cst</name>
  <files>packages/template-engine/src/parser/pg-parser.ts</files>
  <action>
    Create DDL parser using sql-parser-cst (NOT regex):

    Create `packages/template-engine/src/parser/pg-parser.ts`:
    ```typescript
    import { parse } from 'sql-parser-cst';
    import {
      TableDefinition,
      Column,
      ForeignKey,
      Index,
      ParseResult,
      ParseError,
      mapPostgreSQLTypeToTS,
    } from './types.js';

    /**
     * Parse PostgreSQL DDL and extract table definitions
     * Uses sql-parser-cst for proper AST parsing (NOT regex)
     */
    export function parseDDL(ddl: string): ParseResult {
      const tables: TableDefinition[] = [];
      const errors: ParseError[] = [];

      try {
        const ast = parse(ddl, { dialect: 'postgresql' });

        // Traverse AST to extract CREATE TABLE statements
        for (const stmt of ast) {
          try {
            if (stmt.type === 'create_table' || stmt.type === 'create') {
              const table = extractTableDefinition(stmt);
              tables.push(table);
            }
          } catch (error) {
            errors.push({
              message: error instanceof Error ? error.message : String(error),
              line: stmt.location?.start.line,
              column: stmt.location?.start.column,
            });
          }
        }
      } catch (error) {
        // Top-level parsing error
        errors.push({
          message: error instanceof Error ? error.message : String(error),
        });
      }

      return { tables, errors };
    }

    /**
     * Extract table definition from CREATE TABLE statement
     */
    function extractTableDefinition(stmt: any): TableDefinition {
      const tableName = stmt.name?.[0]?.name || stmt.table?.[0]?.name;

      if (!tableName) {
        throw new Error('Table name not found in CREATE TABLE statement');
      }

      const columns: Column[] = [];
      const foreignKeys: ForeignKey[] = [];
      const indexes: Index[] = [];

      // Extract columns and constraints
      if (stmt.columns) {
        for (const col of stmt.columns) {
          if (col.type === 'column_def') {
            columns.push(extractColumn(col));
          } else if (col.type === 'constraint') {
            extractConstraint(col, tableName, foreignKeys, indexes);
          }
        }
      }

      // Extract table-level constraints
      if (stmt.table_constraints) {
        for (const constraint of stmt.table_constraints) {
          extractConstraint(constraint, tableName, foreignKeys, indexes);
        }
      }

      return {
        name: tableName,
        columns,
        foreignKeys,
        indexes,
      };
    }

    /**
     * Extract column definition from column_def node
     */
    function extractColumn(col: any): Column {
      const columnName = col.name?.name;
      const dataType = col.data_type;

      if (!columnName) {
        throw new Error('Column name not found in column definition');
      }

      if (!dataType) {
        throw new Error('Data type not found for column');
      }

      // Extract type name
      const typeName = dataType.type_name?.name || dataType.name || 'unknown';

      // Check for array type
      const isArray = dataType.array === true ||
        (dataType.type_name?.array === true) ||
        typeName.endsWith('[]');

      // Extract enum values if present
      let enumValues: string[] | undefined;
      if (dataType.type_name?.value) {
        // ENUM type with values
        enumValues = dataType.type_name.value.map((v: any) => v.value);
      }

      // Determine nullability
      let nullable = true;
      let isPrimaryKey = false;
      let isUnique = false;
      let defaultValue: string | undefined;

      // Check constraints
      if (col.constraints) {
        for (const constraint of col.constraints) {
          if (constraint.type === 'not_null') {
            nullable = false;
          } else if (constraint.type === 'primary_key') {
            isPrimaryKey = true;
            nullable = false; // Primary keys are never null
          } else if (constraint.type === 'unique') {
            isUnique = true;
          } else if (constraint.type === 'default') {
            defaultValue = serializeDefaultValue(constraint.value);
          }
        }
      }

      // Check for identity column (PostgreSQL 11+)
      if (dataType.identity) {
        isPrimaryKey = true; // Identity columns are usually primary keys
        nullable = false;
      }

      return {
        name: columnName,
        type: mapPostgreSQLTypeToTS(typeName.replace(/\[\]/g, '')),
        nullable,
        defaultValue,
        isPrimaryKey,
        isUnique,
        isArray,
        enumValues,
      };
    }

    /**
     * Extract constraint and populate foreignKeys or indexes
     */
    function extractConstraint(
      constraint: any,
      tableName: string,
      foreignKeys: ForeignKey[],
      indexes: Index[]
    ): void {
      if (constraint.type === 'foreign_key') {
        foreignKeys.push({
          name: constraint.name?.[0]?.name,
          columns: constraint.columns?.map((c: any) => c.name) || [],
          referencedTable: constraint.ref_table?.[0]?.name || '',
          referencedColumns: constraint.ref_columns?.map((c: any) => c.name) || [],
          onDelete: constraint.on_delete,
        });
      } else if (constraint.type === 'primary_key') {
        indexes.push({
          name: constraint.name?.[0]?.name || `pk_${tableName}`,
          columns: constraint.columns?.map((c: any) => c.name) || [],
          isUnique: true,
          isPrimary: true,
        });
      } else if (constraint.type === 'unique') {
        indexes.push({
          name: constraint.name?.[0]?.name || `uq_${tableName}`,
          columns: constraint.columns?.map((c: any) => c.name) || [],
          isUnique: true,
          isPrimary: false,
        });
      } else if (constraint.type === 'index') {
        indexes.push({
          name: constraint.name?.[0]?.name || `idx_${tableName}`,
          columns: constraint.columns?.map((c: any) => c.name) || [],
          isUnique: false,
          isPrimary: false,
        });
      }
    }

    /**
     * Serialize default value to string
     */
    function serializeDefaultValue(value: any): string | undefined {
      if (!value) return undefined;

      if (value.type === 'single_quote_string') {
        return value.value;
      } else if (value.type === 'number') {
        return String(value.value);
      } else if (value.type === 'boolean') {
        return String(value.value);
      } else if (value.type === 'function_call') {
        // Handle functions like CURRENT_DATE, NOW()
        return value.name?.[0]?.name || 'unknown';
      }

      return undefined;
    }

    /**
     * Parse DDL file and return tables (throws if errors)
     */
    export function parseDDLStrict(ddl: string): TableDefinition[] {
      const result = parseDDL(ddl);

      if (result.errors.length > 0) {
        throw new Error(`DDL parsing failed with ${result.errors.length} errors:\n${
          result.errors.map(e => `- ${e.message}`).join('\n')
        }`);
      }

      return result.tables;
    }
    ```
  </action>
  <verify>
    - `cd packages/template-engine && pnpm exec tsc --noEmit` compiles without errors
    - Parser correctly handles PostgreSQL 17 syntax (identity, JSONB, arrays)
    - Error collection follows "continue on error" pattern per CONTEXT decision
  </verify>
  <done>
    PostgreSQL DDL parser is implemented using sql-parser-cst AST
  </done>
</task>

<task type="auto">
  <name>Implement Indonesian national ID validators</name>
  <files>packages/template-engine/src/parser/validators.ts</files>
  <action>
    Create validators for Indonesian national IDs:

    Create `packages/template-engine/src/parser/validators.ts`:
    ```typescript
    import { IndonesianIDValidation } from './types.js';

    /**
     * Indonesian National ID Validators
     * For School ERP domain validation
     */

    /**
     * Validate NISN (Nomor Induk Siswa Nasional)
     * Format: 10 digits, numeric only
     */
    export function validateNISN(nisn: string): IndonesianIDValidation {
      const errors: string[] = [];

      if (!nisn) {
        return { isValid: false, type: 'NISN', errors: ['NISN is required'] };
      }

      // Check length (10 digits)
      if (nisn.length !== 10) {
        errors.push(`NISN must be 10 digits, got ${nisn.length}`);
      }

      // Check numeric only
      if (!/^\d+$/.test(nisn)) {
        errors.push('NISN must contain only digits');
      }

      // Check for common invalid patterns
      if (/^0+$/.test(nisn)) {
        errors.push('NISN cannot be all zeros');
      }

      return {
        isValid: errors.length === 0,
        type: 'NISN',
        errors,
      };
    }

    /**
     * Validate NIP (Nomor Induk Pegawai)
     * Format: 18 digits, structured (birth date embedded)
     * Basic validation only - sophisticated structure validation deferred per RESEARCH
     */
    export function validateNIP(nip: string): IndonesianIDValidation {
      const errors: string[] = [];

      if (!nip) {
        return { isValid: false, type: 'NIP', errors: ['NIP is required'] };
      }

      // Check length (18 digits)
      if (nip.length !== 18) {
        errors.push(`NIP must be 18 digits, got ${nip.length}`);
      }

      // Check numeric only
      if (!/^\d+$/.test(nip)) {
        errors.push('NIP must contain only digits');
      }

      // Check for common invalid patterns
      if (/^0+$/.test(nip)) {
        errors.push('NIP cannot be all zeros');
      }

      // Note: Sophisticated NIP structure validation (birth date position, government codes)
      // is deferred per RESEARCH.md open questions. Basic digit validation is sufficient for POC.

      return {
        isValid: errors.length === 0,
        type: 'NIP',
        errors,
      };
    }

    /**
     * Validate NUPTK (Nomor Unik Pendidik dan Tenaga Kependidikan)
     * Format: 16 digits, numeric only
     */
    export function validateNUPTK(nuptk: string): IndonesianIDValidation {
      const errors: string[] = [];

      if (!nuptk) {
        return { isValid: false, type: 'NUPTK', errors: ['NUPTK is required'] };
      }

      // Check length (16 digits)
      if (nuptk.length !== 16) {
        errors.push(`NUPTK must be 16 digits, got ${nuptk.length}`);
      }

      // Check numeric only
      if (!/^\d+$/.test(nuptk)) {
        errors.push('NUPTK must contain only digits');
      }

      // Check for common invalid patterns
      if (/^0+$/.test(nuptk)) {
        errors.push('NUPTK cannot be all zeros');
      }

      return {
        isValid: errors.length === 0,
        type: 'NUPTK',
        errors,
      };
    }

    /**
     * Detect ID type and validate
     */
    export function validateIndonesianID(id: string): IndonesianIDValidation {
      if (!id) {
        return {
          isValid: false,
          type: 'unknown',
          errors: ['ID is required'],
        };
      }

      // Detect by length
      const length = id.replace(/\D/g, '').length;

      switch (length) {
        case 10:
          return validateNISN(id);
        case 16:
          return validateNUPTK(id);
        case 18:
          return validateNIP(id);
        default:
          return {
            isValid: false,
            type: 'unknown',
            errors: [`Unknown Indonesian ID format: ${length} digits`],
          };
      }
    }

    /**
     * Validate PostgreSQL identifier
     * Prevents SQL injection in dynamic SQL
     */
    export function isValidIdentifier(identifier: string): boolean {
      // PostgreSQL identifiers: letters, digits, underscores, not starting with digit
      return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(identifier);
    }
    ```

    Update `packages/template-engine/src/parser/index.ts`:
    ```typescript
    export {
      parseDDL,
      parseDDLStrict,
      type ParseResult,
      type ParseError,
    } from './pg-parser.js';

    export {
      validateNISN,
      validateNIP,
      validateNUPTK,
      validateIndonesianID,
      isValidIdentifier,
    } from './validators.js';

    export {
      type TableDefinition,
      type Column,
      type ForeignKey,
      type Index,
      mapPostgreSQLTypeToTS,
      POSTGRESQL_TYPE_MAP,
    } from './types.js';
    ```

    Update `packages/template-engine/package.json` exports:
    ```json
    "exports": {
      "./engine": "./src/engine/index.js",
      "./generator": "./src/generator/index.js",
      "./watcher": "./src/watcher/index.js",
      "./parser": "./src/parser/index.js"
    }
    ```
  </action>
  <verify>
    - `cd packages/template-engine && pnpm exec tsc --noEmit` compiles without errors
    - NISN validator: 10 digits, numeric only
    - NIP validator: 18 digits, numeric only (basic validation per RESEARCH)
    - NUPTK validator: 16 digits, numeric only
    - validateIndonesianID() auto-detects ID type by length
  </verify>
  <done>
    Indonesian ID validators are implemented with proper digit counting and format validation
  </done>
</task>

</tasks>

<verification>
Overall phase checks:
- sql-parser-cst is installed and imported correctly
- Parser uses AST traversal, NOT regex
- parseDDL() returns tables and errors (continue-on-error pattern)
- PostgreSQL 17 features are handled (identity, JSONB, arrays, enums)
- Foreign key relationships are extracted correctly
- Indonesian ID validators validate digit counts (NISN=10, NIP=18, NUPTK=16)
- Package exports include parser module
- TypeScript compilation succeeds without errors
</verification>

<success_criteria>
1. parseDDL() extracts table definitions from PostgreSQL DDL using AST
2. Parser handles PostgreSQL 17 features (identity columns, JSONB, arrays, enums)
3. Foreign keys and indexes are correctly extracted from CREATE TABLE statements
4. Indonesian ID validators validate NISN (10), NIP (18), NUPTK (16) digit counts
5. Parser collects all errors and reports at end (continue-on-error pattern)
6. Package exports parser module via @convex-poc/template-engine/parser
</success_criteria>

<output>
After completion, create `.planning/phases/14-template-system/14-02-SUMMARY.md`
</output>
