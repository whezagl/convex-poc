---
phase: 14-template-system
plan: 06
type: execute
wave: 3
depends_on: [14-01, 14-02, 14-04]
files_modified:
  - .templates/crud/fe/index.ts.hbs
  - .templates/crud/fe/types.ts.hbs
  - .templates/crud/fe/api.ts.hbs
  - .templates/crud/fe/hooks.ts.hbs
  - .templates/crud/fe/README.md.hbs
autonomous: true

must_haves:
  truths:
    - "Frontend CRUD templates exist in .templates/crud/fe/"
    - "Templates generate index.ts (exports), types.ts (shared types), api.ts (API client)"
    - "Templates generate hooks.ts (React hooks) and README.md (documentation)"
    - "Templates use DDL parser output (TableDefinition) for context"
    - "Generated API client uses TanStack Query for data fetching"
    - "Generated hooks provide type-safe React hooks for CRUD operations"
  artifacts:
    - path: ".templates/crud/fe/index.ts.hbs"
      provides: "Frontend CRUD exports template"
      min_lines: 10
    - path: ".templates/crud/fe/types.ts.hbs"
      provides: "Shared TypeScript types template"
      min_lines: 30
    - path: ".templates/crud/fe/api.ts.hbs"
      provides: "API client functions template"
      min_lines: 50
    - path: ".templates/crud/fe/hooks.ts.hbs"
      provides: "React hooks template (useQuery, useMutation)"
      min_lines: 60
    - path: ".templates/crud/fe/README.md.hbs"
      provides: "Frontend CRUD documentation template"
      min_lines: 50
  key_links:
    - from: ".templates/crud/fe/*.hbs"
      to: "DDL parser output"
      via: "TableDefinition context"
      pattern: "\\{\\{#each columns\\}\\}\\{\\{/each\\}\\}"
    - from: ".templates/crud/fe/hooks.ts.hbs"
      to: "TanStack Query"
      via: "useQuery, useMutation hooks"
      pattern: "@tanstack/react-query"
---

<objective>
Create frontend CRUD templates (index.ts, types.ts, api.ts, hooks.ts, README.md) for generating React hooks and API clients from DDL parser output.

Purpose: These templates generate type-safe React hooks and API clients for any database table. They integrate with TanStack Query for server state management and provide a clean frontend data layer.
Output: Handlebars templates in .templates/crud/fe/ that render to production-ready frontend CRUD code.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/14-template-system/14-CONTEXT.md
@.planning/phases/14-template-system/14-RESEARCH.md
@.planning/phases/14-template-system/14-01-SUMMARY.md
@.planning/phases/14-template-system/14-02-SUMMARY.md
@.planning/phases/14-template-system/14-04-SUMMARY.md

@packages/template-engine/src/parser/index.ts
</context>

<tasks>

<task type="auto">
  <name>Create frontend CRUD types template</name>
  <files>.templates/crud/fe/types.ts.hbs</files>
  <action>
    Create Handlebars template for shared TypeScript types:

    Create `.templates/crud/fe/types.ts.hbs`:
    ```handlebars
/**
 * {{pascalCase tableName}} Types
 *
 * ⚠️ DO NOT EDIT — Auto-generated on {{formatDate (new Date)}}
 *
 * Database: {{databaseName}}
 * Table: {{tableName}}
 */

/**
 * {{pascalCase tableName}} data model
 */
export interface {{pascalCase tableName}} {
{{#each columns}}
  /** {{#if (isRequired this)}}Required{{else}}Optional{{endif}} {{name}} ({{type}}) */
  {{name}}: {{#if (isRequired this)}}{{typescriptType this}}{{else}}{{typescriptType this}} | null{{/if}};
{{/each}}
}

/**
 * Create {{pascalCase tableName}} input
 */
export interface Create{{pascalCase tableName}}Input {
{{#each columns}}
  {{#unless isPrimaryKey}}
  {{name}}?: {{typescriptType this}};
  {{/unless}}
{{/each}}
}

/**
 * Update {{pascalCase tableName}} input
 */
export interface Update{{pascalCase tableName}}Input {
  {{#findColumn columns 'isPrimaryKey'}}{{name}}{{/findColumn}}: string;
  changes: Partial<Omit<{{pascalCase tableName}}, '{{#findColumn columns 'isPrimaryKey'}}{{name}}{{/findColumn}}'>>;
}

/**
 * {{pascalCase tableName}} query filters
 */
export interface {{pascalCase tableName}}Filters {
{{#each columns}}
  {{#unless isPrimaryKey}}
  {{name}}?: {{#if (eq (typescriptType this) 'string')}}string | string[]{{else}}{{typescriptType this}}{{/if}};
  {{/unless}}
{{/each}}
}

/**
 * {{pascalCase tableName}} list response
 */
export interface {{pascalCase tableName}}ListResponse {
  data: {{pascalCase tableName}}[];
  total: number;
  limit: number;
  offset: number;
}

/**
 * {{pascalCase tableName}} API error response
 */
export interface {{pascalCase tableName}}ApiError {
  message: string;
  errors?: Record<string, string[]>;
}
    ```

    Generates shared types between frontend and backend.
  </action>
  <verify>
    - Template file exists at .templates/crud/fe/types.ts.hbs
    - Generates data model, create input, update input, filters
    - Includes list response and API error types
    - Uses typescriptType helper for type mapping
  </verify>
  <done>
    Frontend CRUD types template is created
  </done>
</task>

<task type="auto">
  <name>Create frontend CRUD API client template</name>
  <files>.templates/crud/fe/api.ts.hbs</files>
  <action>
    Create Handlebars template for API client functions:

    Create `.templates/crud/fe/api.ts.hbs`:
    ```handlebars
/**
 * {{pascalCase tableName}} API Client
 *
 * ⚠️ DO NOT EDIT — Auto-generated on {{formatDate (new Date)}}
 *
 * Database: {{databaseName}}
 * Table: {{tableName}}
 */

import type {
  {{pascalCase tableName}},
  Create{{pascalCase tableName}}Input,
  Update{{pascalCase tableName}}Input,
  {{pascalCase tableName}}Filters,
  {{pascalCase tableName}}ListResponse,
  {{pascalCase tableName}}ApiError,
} from './types.js';

const BASE_URL = import.meta.env.VITE_API_URL || '/api';

/**
 * {{pascalCase tableName}} API client
 */
export const {{camelCase tableName}}Api = {
  /**
   * Get all {{camelCase tableName}} records
   */
  async findAll(
    filters?: {{pascalCase tableName}}Filters,
    limit = 100,
    offset = 0
  ): Promise<{{pascalCase tableName}}ListResponse> {
    const params = new URLSearchParams();
    if (filters) {
      Object.entries(filters).forEach(([key, value]) => {
        if (Array.isArray(value)) {
          value.forEach(v => params.append(key, String(v)));
        } else if (value !== undefined) {
          params.set(key, String(value));
        }
      });
    }
    params.set('limit', String(limit));
    params.set('offset', String(offset));

    const response = await fetch(`${BASE_URL}/{{tableName}}?${params}`);
    if (!response.ok) {
      throw new Error(await response.text());
    }
    return response.json();
  },

  /**
   * Get {{camelCase tableName}} by ID
   */
  async findById(id: string): Promise<{{pascalCase tableName}}> {
    const response = await fetch(`${BASE_URL}/{{tableName}}/${id}`);
    if (!response.ok) {
      throw new Error(await response.text());
    }
    return response.json();
  },

  /**
   * Create new {{camelCase tableName}}
   */
  async create(input: Create{{pascalCase tableName}}Input): Promise<{{pascalCase tableName}}> {
    const response = await fetch(`${BASE_URL}/{{tableName}}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(input),
    });
    if (!response.ok) {
      const error: {{pascalCase tableName}}ApiError = await response.json();
      throw error;
    }
    return response.json();
  },

  /**
   * Update {{camelCase tableName}}
   */
  async update({ {{#findColumn columns 'isPrimaryKey'}}{{name}}{{/findColumn}}, changes }: Update{{pascalCase tableName}}Input): Promise<{{pascalCase tableName}}> {
    const response = await fetch(`${BASE_URL}/{{tableName}}/${{{#findColumn columns 'isPrimaryKey'}}{{name}}{{/findColumn}}}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(changes),
    });
    if (!response.ok) {
      const error: {{pascalCase tableName}}ApiError = await response.json();
      throw error;
    }
    return response.json();
  },

  /**
   * Delete {{camelCase tableName}}
   */
  async delete(id: string): Promise<void> {
    const response = await fetch(`${BASE_URL}/{{tableName}}/${id}`, {
      method: 'DELETE',
    });
    if (!response.ok) {
      throw new Error(await response.text());
    }
  },

  /**
   * Count {{camelCase tableName}} records
   */
  async count(filters?: {{pascalCase tableName}}Filters): Promise<number> {
    const params = new URLSearchParams();
    if (filters) {
      Object.entries(filters).forEach(([key, value]) => {
        if (Array.isArray(value)) {
          value.forEach(v => params.append(key, String(v)));
        } else if (value !== undefined) {
          params.set(key, String(value));
        }
      });
    }

    const response = await fetch(`${BASE_URL}/{{tableName}}/count?${params}`);
    if (!response.ok) {
      throw new Error(await response.text());
    }
    const data = await response.json();
    return data.count;
  },
};
    ```

    Generates API client with fetch for all CRUD operations.
    Uses VITE_API_URL environment variable for base URL.
  </action>
  <verify>
    - Template file exists at .templates/crud/fe/api.ts.hbs
    - Generates findAll, findById, create, update, delete, count methods
    - Uses fetch API for HTTP requests
    - Handles errors and throws on non-OK responses
  </verify>
  <done>
    Frontend CRUD API client template is created
  </done>
</task>

<task type="auto">
  <name>Create frontend CRUD React hooks template</name>
  <files>.templates/crud/fe/hooks.ts.hbs</files>
  <action>
    Create Handlebars template for React hooks with TanStack Query:

    Create `.templates/crud/fe/hooks.ts.hbs`:
    ```handlebars
/**
 * {{pascalCase tableName}} React Hooks
 *
 * ⚠️ DO NOT EDIT — Auto-generated on {{formatDate (new Date)}}
 *
 * Database: {{databaseName}}
 * Table: {{tableName}}
 */

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import type {
  {{pascalCase tableName}},
  Create{{pascalCase tableName}}Input,
  Update{{pascalCase tableName}}Input,
  {{pascalCase tableName}}Filters,
} from './types.js';
import { {{camelCase tableName}}Api } from './api.js';

/**
 * Query key factory for {{camelCase tableName}}
 */
const {{camelCase tableName}}Keys = {
  all: ['{{tableName}}'] as const,
  lists: () => [...{{camelCase tableName}}Keys.all, 'list'] as const,
  list: (filters?: {{pascalCase tableName}}Filters) => [...{{camelCase tableName}}Keys.lists(), filters] as const,
  details: () => [...{{camelCase tableName}}Keys.all, 'detail'] as const,
  detail: (id: string) => [...{{camelCase tableName}}Keys.details(), id] as const,
};

/**
 * Get all {{camelCase tableName}} records
 */
export function use{{pascalCase tableName}}All(
  filters?: {{pascalCase tableName}}Filters,
  options?: { enabled?: boolean; limit?: number; offset?: number }
) {
  return useQuery({
    queryKey: {{camelCase tableName}}Keys.list(filters),
    queryFn: () => {{camelCase tableName}}Api.findAll(filters, options?.limit, options?.offset),
    enabled: options?.enabled ?? true,
  });
}

/**
 * Get {{camelCase tableName}} by ID
 */
export function use{{pascalCase tableName}}(id: string, options?: { enabled?: boolean }) {
  return useQuery({
    queryKey: {{camelCase tableName}}Keys.detail(id),
    queryFn: () => {{camelCase tableName}}Api.findById(id),
    enabled: (options?.enabled ?? true) && !!id,
  });
}

/**
 * Create {{camelCase tableName}}
 */
export function useCreate{{pascalCase tableName}}() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (input: Create{{pascalCase tableName}}Input) => {{camelCase tableName}}Api.create(input),
    onSuccess: () => {
      // Invalidate list queries to refetch
      queryClient.invalidateQueries({ queryKey: {{camelCase tableName}}Keys.lists() });
    },
  });
}

/**
 * Update {{camelCase tableName}}
 */
export function useUpdate{{pascalCase tableName}}() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (input: Update{{pascalCase tableName}}Input) => {{camelCase tableName}}Api.update(input),
    onSuccess: (data) => {
      // Invalidate specific item query
      queryClient.invalidateQueries({ queryKey: {{camelCase tableName}}Keys.detail(data.{{#findColumn columns 'isPrimaryKey'}}{{name}}{{/findColumn}}) });
      // Invalidate list queries
      queryClient.invalidateQueries({ queryKey: {{camelCase tableName}}Keys.lists() });
    },
  });
}

/**
 * Delete {{camelCase tableName}}
 */
export function useDelete{{pascalCase tableName}}() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id: string) => {{camelCase tableName}}Api.delete(id),
    onSuccess: () => {
      // Invalidate list queries
      queryClient.invalidateQueries({ queryKey: {{camelCase tableName}}Keys.lists() });
    },
  });
}

/**
 * Count {{camelCase tableName}} records
 */
export function use{{pascalCase tableName}}Count(
  filters?: {{pascalCase tableName}}Filters,
  options?: { enabled?: boolean }
) {
  return useQuery({
    queryKey: [...{{camelCase tableName}}Keys.all, 'count', filters] as const,
    queryFn: () => {{camelCase tableName}}Api.count(filters),
    enabled: options?.enabled ?? true,
  });
}
    ```

    Generates TanStack Query hooks with proper cache invalidation.
  </action>
  <verify>
    - Template file exists at .templates/crud/fe/hooks.ts.hbs
    - Generates useQuery hooks for data fetching
    - Generates useMutation hooks for mutations (create, update, delete)
    - Implements query key factory for cache management
    - Invalidates cache on mutations for data consistency
  </verify>
  <done>
    Frontend CRUD React hooks template is created with TanStack Query integration
  </done>
</task>

<task type="auto">
  <name>Create frontend CRUD index and README templates</name>
  <files>.templates/crud/fe/index.ts.hbs, .templates/crud/fe/README.md.hbs</files>
  <action>
    Create Handlebars templates for exports and documentation:

    1. Create `.templates/crud/fe/index.ts.hbs`:
    ```handlebars
/**
 * {{pascalCase tableName}} Module
 *
 * ⚠️ DO NOT EDIT — Auto-generated on {{formatDate (new Date)}}
 *
 * Database: {{databaseName}}
 * Table: {{tableName}}
 */

// Types
export type {
  {{pascalCase tableName}},
  Create{{pascalCase tableName}}Input,
  Update{{pascalCase tableName}}Input,
  {{pascalCase tableName}}Filters,
  {{pascalCase tableName}}ListResponse,
  {{pascalCase tableName}}ApiError,
} from './types.js';

// API client
export { {{camelCase tableName}}Api } from './api.js';

// React hooks
export {
  use{{pascalCase tableName}}All,
  use{{pascalCase tableName}},
  useCreate{{pascalCase tableName}},
  useUpdate{{pascalCase tableName}},
  useDelete{{pascalCase tableName}},
  use{{pascalCase tableName}}Count,
} from './hooks.js';
    ```

    2. Create `.templates/crud/fe/README.md.hbs`:
    ```handlebars
# {{pascalCase tableName}} Frontend Module

⚠️ **DO NOT EDIT — Auto-generated on {{formatDate (new Date)}}**

Database table: `{{tableName}}`

## Overview

This module provides type-safe React hooks and API client for the `{{tableName}}` table. Built with TanStack Query for server state management.

## Installation

This module is auto-generated. No installation needed.

## Usage

### React Hooks

```typescript
import {
  use{{pascalCase tableName}}All,
  use{{pascalCase tableName}},
  useCreate{{pascalCase tableName}},
  useUpdate{{pascalCase tableName}},
  useDelete{{pascalCase tableName}},
} from './{{camelCase tableName}}';

// Fetch all records
function {{pascalCase tableName}}List() {
  const { data, isLoading, error } = use{{pascalCase tableName}}All();

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <ul>
      {data?.data.map(item => (
        <li key={item.{{#findColumn columns 'isPrimaryKey'}}{{name}}{{/findColumn}}}>{item.{{#findColumn columns 'name'}}{{name}}{{/findColumn}}}</li>
      ))}
    </ul>
  );
}

// Fetch single record
function {{pascalCase tableName}}Details({ id }: { id: string }) {
  const { data, isLoading, error } = use{{pascalCase tableName}}(id);

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return <div>{{pascalCase tableName}}: {data?.{{#findColumn columns 'name'}}{{name}}{{/findColumn}}}</div>;
}

// Create record
function Create{{pascalCase tableName}}Form() {
  const create{{pascalCase tableName}} = useCreate{{pascalCase tableName}}();

  const handleSubmit = (data: Create{{pascalCase tableName}}Input) => {
    create{{pascalCase tableName}}.mutate(data, {
      onSuccess: () => {
        alert('{{pascalCase tableName}} created!');
      },
    });
  };

  return (
    <form onSubmit={(e) => {
      e.preventDefault();
      handleSubmit({ /* form data */ });
    }}>
      {/* form fields */}
      <button type="submit" disabled={create{{pascalCase tableName}}.isPending}>
        {create{{pascalCase tableName}}.isPending ? 'Creating...' : 'Create'}
      </button>
    </form>
  );
}

// Update record
function Update{{pascalCase tableName}}Form({ id }: { id: string }) {
  const { data } = use{{pascalCase tableName}}(id);
  const update{{pascalCase tableName}} = useUpdate{{pascalCase tableName}}();

  const handleSubmit = (changes: Partial<{{pascalCase tableName}}>) => {
    update{{pascalCase tableName}}.mutate({
      {{#findColumn columns 'isPrimaryKey'}}{{name}}{{/findColumn}}: id,
      changes,
    });
  };

  return (
    <form onSubmit={(e) => {
      e.preventDefault();
      handleSubmit({ /* changes */ });
    }}>
      {/* form fields */}
      <button type="submit" disabled={update{{pascalCase tableName}}.isPending}>
        {update{{pascalCase tableName}}.isPending ? 'Updating...' : 'Update'}
      </button>
    </form>
  );
}

// Delete record
function Delete{{pascalCase tableName}}Button({ id }: { id: string }) {
  const delete{{pascalCase tableName}} = useDelete{{pascalCase tableName}}();

  return (
    <button
      onClick={() => delete{{pascalCase tableName}}.mutate(id)}
      disabled={delete{{pascalCase tableName}}.isPending}
    >
      {delete{{pascalCase tableName}}.isPending ? 'Deleting...' : 'Delete'}
    </button>
  );
}
```

### API Client

If you need direct API access (without React hooks):

```typescript
import { {{camelCase tableName}}Api } from './{{camelCase tableName}}';

// Fetch all
const all = await {{camelCase tableName}}Api.findAll();

// Fetch by ID
const one = await {{camelCase tableName}}Api.findById('id');

// Create
const created = await {{camelCase tableName}}Api.create({ /* data */ });

// Update
const updated = await {{camelCase tableName}}Api.update({
  {{#findColumn columns 'isPrimaryKey'}}{{name}}{{/findColumn}}: 'id',
  changes: { /* changes */ }
});

// Delete
await {{camelCase tableName}}Api.delete('id');
```

## Types

See `types.ts` for complete type definitions:

- `{{pascalCase tableName}}` - Data model
- `Create{{pascalCase tableName}}Input` - Create input
- `Update{{pascalCase tableName}}Input` - Update input
- `{{pascalCase tableName}}Filters` - Query filters
- `{{pascalCase tableName}}ListResponse` - List response
- `{{pascalCase tableName}}ApiError` - API error

## Table Schema

| Column | Type | Nullable | Description |
|--------|------|----------|-------------|
{{#each columns}}
| `{{name}}` | {{type}} | {{#if nullable}}Yes{{else}}No{{/if}} | {{#if comment}}{{{comment}}}{{else}}-{{/if}} |
{{/each}}

## Environment Variables

Ensure `VITE_API_URL` is set in your `.env` file:

```env
VITE_API_URL=http://localhost:3000/api
```
    ```

    Index re-exports all module components.
    README documents usage, hooks, API client, and types.
  </action>
  <verify>
    - Both template files exist
    - index.ts re-exports types, API client, and React hooks
    - README.md provides comprehensive usage examples
    - README documents all hooks with code examples
    - README includes table schema reference
  </verify>
  <done>
    Frontend CRUD index and README templates are created
  </done>
</task>

</tasks>

<verification>
Overall phase checks:
- All 5 frontend CRUD templates exist in .templates/crud/fe/ directory
- Templates use DDL parser output (TableDefinition) for context
- Templates use Handlebars helpers (pascalCase, camelCase, typescriptType)
- Auto-generated warnings are included in all generated files
- API client uses fetch for HTTP requests
- React hooks use TanStack Query (useQuery, useMutation)
- Query key factory implements cache management
- Mutations invalidate cache for data consistency
- README.md provides usage examples and documents all hooks
- index.ts re-exports all module components
</verification>

<success_criteria>
1. All 5 frontend CRUD templates exist (index.ts, types.ts, api.ts, hooks.ts, README.md)
2. Templates generate type-safe React hooks (useQuery, useMutation)
3. TanStack Query integration provides caching, loading states, and error handling
4. API client uses fetch with proper error handling
5. Query key factory implements efficient cache management
6. Mutations invalidate related queries for data consistency
7. README.md documents usage with code examples for all hooks
8. index.ts provides clean module exports
</success_criteria>

<output>
After completion, create `.planning/phases/14-template-system/14-06-SUMMARY.md`
</output>
