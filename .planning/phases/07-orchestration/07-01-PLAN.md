---
phase: 07-orchestration
plan: 01
type: execute
---

<objective>
Create sequential workflow orchestration for Planner → Coder → Reviewer agent coordination with filesystem state passing and Convex workflow tracking.

Purpose: Enable multi-agent coordination by orchestrating the three specialized agents (Planner, Coder, Reviewer) in a sequential workflow, demonstrating the complete autonomous coding system.

Output: Working orchestrator that runs Planner→Coder→Reviewer workflow with state persistence and error handling.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-orchestration/07-RESEARCH.md

# Auto-selected based on dependency graph (from frontmatter):
@.planning/phases/03-agent-foundation/03-01-SUMMARY.md
@.planning/phases/04-planner-agent/04-01-SUMMARY.md
@.planning/phases/05-coder-agent/05-01-SUMMARY.md
@.planning/phases/06-reviewer-agent/06-01-SUMMARY.md

# Key files from frontmatter (relevant to this phase):
@src/agents/BaseAgent.ts
@src/agents/PlannerAgent.ts
@src/agents/CoderAgent.ts
@src/agents/ReviewerAgent.ts
@src/types/plan.ts
@src/types/code.ts
@src/types/review.ts
@convex/schema.ts
@convex/workflows.ts

**Tech stack available:** [@anthropic-ai/claude-agent-sdk, Convex for state storage, Filesystem for artifacts, Node.js fs/promises for file I/O]
**Established patterns:** [BaseAgent extension pattern, execute{Domain} methods, workflowId tracking via executeWithWorkflow(), JSON extraction from markdown code blocks, comprehensive validation helpers]
**Constraining decisions:**
- [Phase 03-01]: Abstract BaseAgent class with protected Convex integration methods (SDK + Convex pattern)
- [Phase 03-01]: SessionStart/SessionEnd hooks for automatic state persistence (manual trigger pattern)
- [Phase 03-01]: Subclasses implement only getSystemPrompt() - BaseAgent handles all Convex details
- [Phase 04-01]: Use domain-specific execute method (executePlan vs execute) to avoid BaseAgent signature conflict
- [Phase 05-01]: Use domain-specific execute method (executeCode vs execute) to avoid BaseAgent signature conflict
- [Phase 06-01]: Use domain-specific execute method (executeReview vs execute) to avoid BaseAgent signature conflict
- [Phase 07-RESEARCH]: Sequential orchestration with filesystem state passing (recommended over complex workflow engines)
- [Phase 07-RESEARCH]: Filesystem as "shared memory" between agents (plan.md → code → review.md)

**Issues being addressed:** None

**Concerns being verified:** None
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define orchestration types and interfaces</name>
  <files>src/types/workflow.ts</files>
  <action>Create src/types/workflow.ts with:
- WorkflowContext interface: task (string), workspace (string), workflowId (optional Id<"workflows">)
- WorkflowStep interface: name (string), agent (string), status ("pending" | "in_progress" | "completed" | "failed"), startTime (number), endTime (optional number), output (optional string), error (optional string)
- WorkflowResult interface: success (boolean), steps (WorkflowStep[]), artifacts (Artifact[]), finalReview (optional ReviewResult)
- Artifact interface: type ("plan" | "code" | "review"), path (string), content (string)
- ExecuteWorkflowConfig interface: workspace (string), continueOnError (boolean, default false)
- Export types from src/types/index.ts if it exists, otherwise export directly from workflow.ts
Follow pattern from src/types/plan.ts and src/types/code.ts</action>
  <verify>TypeScript compilation passes, can import { WorkflowContext, WorkflowResult, ExecuteWorkflowConfig } from src/types/workflow.js</verify>
  <done>Workflow types defined, all TypeScript compilation succeeds</done>
</task>

<task type="auto">
  <name>Task 2: Create Orchestrator class for sequential workflow execution</name>
  <files>src/orchestrator/SequentialOrchestrator.ts</files>
  <action>Create SequentialOrchestrator class in src/orchestrator/SequentialOrchestrator.ts:
- Constructor accepts ExecuteWorkflowConfig with workspace path and continueOnError flag
- executeWorkflow() method accepts WorkflowContext (task, optional workflowId)
- Returns Promise<WorkflowResult> with all step results and artifacts
- Implements sequential execution: PlannerAgent → CoderAgent → ReviewerAgent
- Uses filesystem for state passing (workspace/plan.json, workspace/code.json, workspace/review.json)
- Each step updates workflow status in Convex via updateWorkflowStatus mutation
- Each agent executes with workflowId for session tracking
- Error handling: wrap each step in try-catch, continue based on continueOnError flag
- Track timing: record startTime/endTime for each step
- Collect artifacts: save each agent's output as JSON artifact
Follow BaseAgent pattern for Convex integration (use existing convex/client.ts for mutations)</action>
  <verify>TypeScript compilation passes, can import { SequentialOrchestrator } from src/orchestrator/index.js</verify>
  <done>SequentialOrchestrator class created with executeWorkflow() method handling full Planner→Coder→Reviewer flow</done>
</task>

<task type="auto">
  <name>Task 3: Create filesystem state management utilities</name>
  <files>src/orchestrator/state.ts</files>
  <action>Create src/orchestrator/state.ts with:
- saveArtifact() function: writes artifact to JSON file in workspace directory
- loadArtifact() function: reads JSON artifact from workspace directory
- planToJson() and planFromJson() helpers: convert PlanResult to/from JSON
- codeToJson() and codeFromJson() helpers: convert CodeResult to/from JSON
- reviewToJson() and reviewFromJson() helpers: convert ReviewResult to/from JSON
- createWorkspace() function: creates workspace directory if it doesn't exist
- clearWorkspace() function: removes all files from workspace directory
- Use fs/promises with mkdir/writeFile/readFile for file operations
- Use JSON.stringify/parse with 2-space indentation for readable artifacts
Follow Node.js fs/promises patterns for async file I/O</action>
  <verify>TypeScript compilation passes, can import { saveArtifact, loadArtifact } from src/orchestrator/state.js</verify>
  <done>State management utilities created with save/load functions for all artifact types</done>
</task>

<task type="auto">
  <name>Task 4: Export orchestrator components and create comprehensive tests</name>
  <files>src/orchestrator/index.ts, tests/orchestrator.test.ts</files>
  <action>
1. Create src/orchestrator/index.ts:
   - Export SequentialOrchestrator class
   - Export ExecuteWorkflowConfig type
   - Export WorkflowContext and WorkflowResult types

2. Create tests/orchestrator.test.ts with comprehensive tests:
   - Mock agent calls to avoid real API usage
   - Mock Convex mutations for workflow state tracking
   - Test successful workflow execution (all 3 agents succeed)
   - Test planner failure handling (workflow stops)
   - Test coder failure handling (depends on continueOnError flag)
   - Test reviewer failure handling (workflow completes with error)
   - Test artifact persistence (plan.json, code.json, review.json created)
   - Test workflow status updates (pending → in_progress → completed)
   - Test timing tracking (startTime < endTime for each step)
   - Test continueOnError=true behavior (workflow continues after coder failure)
   - Test continueOnError=false behavior (workflow stops after first failure)
   - Mock fs operations for workspace/file operations
   - Total: ~15-20 tests covering all workflow paths

Use vi.mock() for @anthropic-ai/claude-agent-sdk, convex client, and fs/promises
</action>
  <verify>npm test passes for orchestrator.test.ts, all tests pass, no TypeScript errors</verify>
  <done>15-20 tests created covering workflow execution, error handling, artifact persistence, all passing</done>
</task>

<task type="auto">
  <name>Task 5: Create example workflow execution script</name>
  <files>examples/workflow-execution.ts</files>
  <action>Create examples/workflow-execution.ts demonstrating:
- Import SequentialOrchestrator and ExecuteWorkflowConfig
- Configure workspace path (e.g., ./workspace)
- Create workflow context with sample task (e.g., "Create a User model with authentication")
- Execute workflow: const orchestrator = new SequentialOrchestrator({ workspace: "./workspace" })
- Handle result: check success status, iterate steps, display artifacts
- Show error handling: try-catch with console.error for failures
- Demonstrate continueOnError flag (two examples: with false, with true)
- Display final review results if available
Add comments explaining each step and the workflow flow
Follow pattern from examples/basic-usage.ts</action>
  <verify>Script compiles without errors, imports work correctly, example is readable and well-documented</verify>
  <done>Example workflow script created demonstrating successful and failure scenarios</done>
</task>

<task type="auto">
  <name>Task 6: Document orchestration patterns in agents README</name>
  <files>src/agents/README.md</files>
  <action>Update src/agents/README.md:
- Add "Orchestration" section after ReviewerAgent
- Document SequentialOrchestrator usage with code example
- Explain workflow flow: Planner → Coder → Reviewer
- Show ExecuteWorkflowConfig options (workspace, continueOnError)
- Show WorkflowResult structure (success, steps, artifacts, finalReview)
- Document artifact persistence (plan.json, code.json, review.json)
- Add error handling patterns (continueOnError behavior)
- Update comparison table to include orchestrator
Follow same format as existing agent documentation sections
</action>
  <verify>README.md includes Orchestration section with examples, compiles without errors</verify>
  <done>README.md updated with orchestration documentation following existing pattern</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm test` passes all tests (existing + new orchestrator tests)
- [ ] No TypeScript errors
- [ ] SequentialOrchestrator can be imported from src/orchestrator/index.js
- [ ] Workflow types can be imported from src/types/workflow.js
- [ ] Example script runs without errors (with mocked agents)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Orchestration follows sequential filesystem state passing pattern from research
- Tests cover all workflow paths (success, failures, continueOnError)
  </success_criteria>

<output>
After completion, create `.planning/phases/07-orchestration/07-01-SUMMARY.md`:

# Phase 7 Plan 1: Orchestration Summary

**[Substantive one-liner - what shipped, not "phase complete"]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.ts` - Description
- `path/to/another.ts` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Phase 7 complete. Ready for Phase 8: Example Task.
</output>
