---
phase: 15-agent-orchestration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/agent-orchestrator/package.json
  - packages/agent-orchestrator/src/queue/TaskQueue.ts
  - packages/agent-orchestrator/src/queue/FileLockManager.ts
  - packages/agent-orchestrator/src/types/queue.ts
autonomous: true

must_haves:
  truths:
    - "Task queue executes tasks by priority with max 5 concurrent"
    - "File locks prevent race conditions during parallel file writes"
    - "Queue state tracks pending, running, and completed tasks"
    - "File locks release properly even when errors occur"
  artifacts:
    - path: "packages/agent-orchestrator/src/queue/TaskQueue.ts"
      provides: "Priority queue with concurrency control using p-queue"
      exports: ["TaskQueue"]
    - path: "packages/agent-orchestrator/src/queue/FileLockManager.ts"
      provides: "File locking wrapper using proper-lockfile"
      exports: ["FileLockManager"]
    - path: "packages/agent-orchestrator/src/types/queue.ts"
      provides: "Type definitions for queue operations"
      exports: ["QueueOptions", "TaskOptions"]
  key_links:
    - from: "TaskQueue.ts"
      to: "p-queue"
      via: "import PQueue from 'p-queue'"
      pattern: "import PQueue from 'p-queue'"
    - from: "FileLockManager.ts"
      to: "proper-lockfile"
      via: "import lock from 'proper-lockfile'"
      pattern: "import lock from 'proper-lockfile'"
---

<objective>
Build orchestration foundation with TaskQueue and FileLockManager for parallel agent execution.

Purpose: Enable priority-based task scheduling with concurrency limits (max 5) and prevent file write conflicts during parallel code generation.

Output: TaskQueue class with p-queue integration, FileLockManager with proper-lockfile, queue type definitions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/15-agent-orchestration/15-RESEARCH.md
@.planning/phases/15-agent-orchestration/15-CONTEXT.md
@packages/agent-orchestrator/package.json
@packages/shared-types/src/task.ts
@packages/shared-types/src/subtask.ts
</context>

<tasks>

<task type="auto">
  <name>Install queue and locking dependencies</name>
  <files>packages/agent-orchestrator/package.json</files>
  <action>
    Add p-queue and proper-lockfile to dependencies:

    ```json
    "dependencies": {
      "@anthropic-ai/claude-agent-sdk": "^0.2.7",
      "openai": "^6.16.0",
      "@convex-poc/shared-types": "workspace:*",
      "@convex-poc/convex-client": "workspace:*",
      "p-queue": "^8.0.1",
      "proper-lockfile": "^4.1.2"
    }
    ```

    Run: pnpm install
  </action>
  <verify>grep -E '"p-queue"|"proper-lockfile"' packages/agent-orchestrator/package.json</verify>
  <done>p-queue and proper-lockfile added to dependencies and installed</done>
</task>

<task type="auto">
  <name>Create queue type definitions</name>
  <files>packages/agent-orchestrator/src/types/queue.ts</files>
  <action>
    Create type definitions for queue operations:

    ```typescript
    // @convex-poc/agent-orchestrator/types/queue - Queue type definitions

    import type { Id } from "@convex-poc/shared-types/task";

    export interface TaskOptions {
      taskId: Id;
      priority: number; // 1 (low) to 10 (high)
      timeout?: number; // milliseconds, default 300000 (5 min)
    }

    export interface QueueOptions {
      concurrency: number; // Max concurrent tasks, default 5
      autoStart?: boolean; // Auto-start queue, default true
      timeout?: number; // Default timeout per task, default 300000
      throwOnTimeout?: boolean; // Throw when timeout, default true
    }

    export interface FileLockOptions {
      retries?: number; // Retry attempts, default 10
      stale?: number; // ms before lock is considered stale, default 10000
      update?: number; // ms to update lockfile mtime, default 2000
    }

    export interface QueueStats {
      size: number; // Pending tasks
      pending: number; // Running tasks
      concurrency: number; // Max concurrency
    }
    ```

    Export types from index.ts
  </action>
  <verify>cat packages/agent-orchestrator/src/types/queue.ts</verify>
  <done>Queue type definitions created with TaskOptions, QueueOptions, FileLockOptions, QueueStats</done>
</task>

<task type="auto">
  <name>Implement FileLockManager with proper-lockfile</name>
  <files>packages/agent-orchestrator/src/queue/FileLockManager.ts</files>
  <action>
    Create FileLockManager class using proper-lockfile:

    ```typescript
    // @convex-poc/agent-orchestrator/queue/FileLockManager - File locking for parallel operations

    import lock from "proper-lockfile";
    import type { FileLockOptions } from "../types/queue.js";
    import { promises as fs } from "fs";

    export class FileLockManager {
      private locks = new Map<string, () => Promise<void>>();

      /**
       * Acquires a lock for the specified file path.
       *
       * @param filePath - Absolute path to the file
       * @param options - Lock options with retries and stale detection
       * @returns Release function that must be called when done
       */
      async acquireLock(
        filePath: string,
        options: FileLockOptions = {}
      ): Promise<() => Promise<void>> {
        const {
          retries = 10,
          stale = 10000, // 10 seconds
          update = 2000, // Update every 2 seconds
        } = options;

        // Ensure file exists before locking
        try {
          await fs.access(filePath);
        } catch {
          // File doesn't exist, create empty file
          await fs.writeFile(filePath, "");
        }

        // Acquire lock
        const release = await lock(filePath, {
          retries,
          stale,
          update,
        });

        this.locks.set(filePath, release);
        return release;
      }

      /**
       * Releases a lock for the specified file path.
       *
       * @param filePath - Absolute path to the file
       */
      async releaseLock(filePath: string): Promise<void> {
        const release = this.locks.get(filePath);
        if (release) {
          await release();
          this.locks.delete(filePath);
        }
      }

      /**
       * Executes a function while holding a file lock.
       * The lock is always released, even if the function throws.
       *
       * @param filePath - Absolute path to the file
       * @param fn - Async function to execute while holding lock
       * @param options - Lock options
       * @returns Result of the function
       */
      async withLock<T>(
        filePath: string,
        fn: () => Promise<T>,
        options?: FileLockOptions
      ): Promise<T> {
        await this.acquireLock(filePath, options);
        try {
          return await fn();
        } finally {
          await this.releaseLock(filePath);
        }
      }

      /**
       * Releases all active locks.
       * Useful for cleanup on shutdown.
       */
      async releaseAll(): Promise<void> {
        const releasePromises = Array.from(this.locks.values()).map(release =>
          release().catch(err => console.error(`[FileLockManager] Failed to release lock: ${err}`))
        );
        await Promise.all(releasePromises);
        this.locks.clear();
      }

      /**
       * Gets the count of active locks.
       * Useful for monitoring potential deadlocks.
       */
      getLockCount(): number {
        return this.locks.size;
      }
    }
    ```

    Export from index.ts: `export { FileLockManager } from "./queue/FileLockManager.js";`
  </action>
  <verify>grep -q "class FileLockManager" packages/agent-orchestrator/src/queue/FileLockManager.ts</verify>
  <done>FileLockManager implemented with acquireLock, releaseLock, withLock, releaseAll methods</done>
</task>

<task type="auto">
  <name>Implement TaskQueue with p-queue</name>
  <files>packages/agent-orchestrator/src/queue/TaskQueue.ts</files>
  <action>
    Create TaskQueue class using p-queue:

    ```typescript
    // @convex-poc/agent-orchestrator/queue/TaskQueue - Priority queue with concurrency control

    import PQueue from "p-queue";
    import type { QueueOptions, TaskOptions, QueueStats } from "../types/queue.js";

    export class TaskQueue {
      private queue: PQueue;
      private taskCount = 0;

      constructor(options: QueueOptions = {}) {
        const {
          concurrency = 5, // Max 5 concurrent tasks per research
          autoStart = true,
          timeout = 300000, // 5 minutes
          throwOnTimeout = true,
        } = options;

        this.queue = new PQueue({
          concurrency,
          autoStart,
          timeout,
          throwOnTimeout,
        });

        // Log queue events for monitoring
        this.queue.on("active", () => {
          console.log(`[TaskQueue] Task started. Pending: ${this.queue.size}, Running: ${this.queue.pending}`);
        });

        this.queue.on("next", () => {
          console.log(`[TaskQueue] Task completed. Pending: ${this.queue.size}, Running: ${this.queue.pending}`);
        });

        this.queue.on("idle", () => {
          console.log(`[TaskQueue] Queue is idle. Total tasks processed: ${this.taskCount}`);
        });
      }

      /**
       * Adds a task to the queue with priority.
       *
       * @param taskFn - Async function to execute
       * @param options - Task options with priority (1=low, 10=high)
       * @returns Promise that resolves when task completes
       */
      async add<T>(
        taskFn: () => Promise<T>,
        options: TaskOptions
      ): Promise<T> {
        const { priority, taskId, timeout } = options;

        this.taskCount++;

        return this.queue.add(taskFn, {
          priority, // Higher priority = executes first
        });
      }

      /**
       * Adds multiple tasks to the queue.
       * Tasks execute in parallel up to concurrency limit.
       *
       * @param tasks - Array of task functions and options
       * @returns Array of results in the same order as input
       */
      async addMany<T>(
        tasks: Array<{
          taskFn: () => Promise<T>;
          options: TaskOptions;
        }>
      ): Promise<T[]> {
        const promises = tasks.map(({ taskFn, options }) =>
          this.add(taskFn, options)
        );
        return Promise.all(promises);
      }

      /**
       * Waits for all tasks in the queue to complete.
       *
       * @returns Promise that resolves when queue is idle
       */
      async onIdle(): Promise<void> {
        return this.queue.onIdle();
      }

      /**
       * Pauses the queue (no new tasks will start).
       * Currently running tasks continue to completion.
       */
      pause(): void {
        this.queue.pause();
        console.log("[TaskQueue] Queue paused");
      }

      /**
       * Starts the queue after pausing.
       */
      start(): void {
        this.queue.start();
        console.log("[TaskQueue] Queue started");
      }

      /**
       * Clears all pending tasks from the queue.
       * Currently running tasks are not affected.
       */
      clear(): void {
        this.queue.clear();
        console.log("[TaskQueue] Queue cleared");
      }

      /**
       * Gets current queue statistics.
       *
       * @returns Queue stats with size, pending count, and concurrency
       */
      getStats(): QueueStats {
        return {
          size: this.queue.size,
          pending: this.queue.pending,
          concurrency: this.queue.concurrency,
        };
      }

      /**
       * Gets the total number of tasks processed.
       */
      getTotalProcessed(): number {
        return this.taskCount;
      }

      /**
       * Checks if the queue is empty (no pending or running tasks).
       */
      isEmpty(): boolean {
        return this.queue.size === 0 && this.queue.pending === 0;
      }
    }
    ```

    Export from index.ts: `export { TaskQueue } from "./queue/TaskQueue.js";`
  </action>
  <verify>grep -q "class TaskQueue" packages/agent-orchestrator/src/queue/TaskQueue.ts</verify>
  <done>TaskQueue implemented with priority scheduling, concurrency control, and monitoring</done>
</task>

<task type="auto">
  <name>Update package exports for queue modules</name>
  <files>packages/agent-orchestrator/package.json</files>
  <action>
    Update package.json exports to include queue modules:

    ```json
    "exports": {
      "./orchestrator": "./src/orchestrator.ts",
      "./planner": "./src/planner.ts",
      "./coder": "./src/coder.ts",
      "./reviewer": "./src/reviewer.ts",
      "./queue": "./src/queue/index.ts",
      "./types/queue": "./src/types/queue.ts"
    }
    ```

    Create packages/agent-orchestrator/src/queue/index.ts:

    ```typescript
    // @convex-poc/agent-orchestrator/queue - Queue and locking utilities

    export { TaskQueue } from "./TaskQueue.js";
    export { FileLockManager } from "./FileLockManager.js";
    ```
  </action>
  <verify>cat packages/agent-orchestrator/src/queue/index.ts</verify>
  <done>Queue modules exported from package with TaskQueue and FileLockManager</done>
</task>

</tasks>

<verification>
# Post-Execution Verification

## Build Check
- Run: `pnpm --filter @convex-poc/agent-orchestrator build`
- Expected: Clean TypeScript compilation with no errors

## Import Check
```bash
node -e "
import('@convex-poc/agent-orchestrator/queue').then(m => {
  console.log('TaskQueue:', typeof m.TaskQueue);
  console.log('FileLockManager:', typeof m.FileLockManager);
})
"
```

## Dependency Check
- p-queue installed in node_modules/@convex-poc/agent-orchestrator/node_modules
- proper-lockfile installed in node_modules/@convex-poc/agent-orchestrator/node_modules
</verification>

<success_criteria>
1. TaskQueue class instantiated with concurrency: 5 executes tasks with priority ordering
2. FileLockManager acquires and releases locks correctly, even on error paths
3. Queue statistics (size, pending, concurrency) accessible via getStats()
4. All TypeScript types compile without errors
5. Package exports allow importing TaskQueue and FileLockManager
</success_criteria>

<output>
After completion, create `.planning/phases/15-agent-orchestration/15-01-SUMMARY.md`
</output>
