---
phase: 15-agent-orchestration
plan: 04
type: execute
wave: 2
depends_on: ["15-01", "15-02"]
files_modified:
  - packages/agent-orchestrator/src/agents/BECRUDAgent.ts
  - packages/agent-orchestrator/src/agents/FECRUDAgent.ts
  - packages/agent-orchestrator/src/agents/UICRUDAgent.ts
  - packages/agent-orchestrator/src/agents/index.ts
autonomous: true

must_haves:
  truths:
    - "BE CRUD APIs agent spawns N sub-tasks (one per table)"
    - "FE CRUD Services agent spawns N sub-tasks (one per table)"
    - "UI CRUD Pages agent spawns N sub-tasks (one per table)"
    - "Each CRUD agent generates code for a single table per sub-task"
    - "Agents use Phase 14 CRUD templates with table-specific variables"
  artifacts:
    - path: "packages/agent-orchestrator/src/agents/BECRUDAgent.ts"
      provides: "Backend CRUD APIs agent"
      exports: ["BECRUDAgent"]
    - path: "packages/agent-orchestrator/src/agents/FECRUDAgent.ts"
      provides: "Frontend CRUD services agent"
      exports: ["FECRUDAgent"]
    - path: "packages/agent-orchestrator/src/agents/UICRUDAgent.ts"
      provides: "UI CRUD pages agent"
      exports: ["UICRUDAgent"]
  key_links:
    - from: "BECRUDAgent.ts"
      to: "./BaseCRUDAgent"
      via: "extends BaseCRUDAgent"
      pattern: "class BECRUDAgent extends BaseCRUDAgent"
    - from: "BECRUDAgent.ts"
      to: "@convex-poc/template-engine/parser"
      via: "import { parseDDL } from '@convex-poc/template-engine/parser'"
      pattern: "parseDDL"
    - from: "FECRUDAgent.ts"
      to: "./BaseCRUDAgent"
      via: "extends BaseCRUDAgent"
      pattern: "class FECRUDAgent extends BaseCRUDAgent"
    - from: "UICRUDAgent.ts"
      to: "./BaseCRUDAgent"
      via: "extends BaseCRUDAgent"
      pattern: "class UICRUDAgent extends BaseCRUDAgent"
---

<objective>
Implement CRUD agents (BE APIs, FE Services, UI Pages) that generate table-specific code using Phase 14 templates.

Purpose: Each agent spawns N sub-tasks (one per table), generating CRUD code for individual tables using templates from Phase 14-05, 14-06, 14-07.

Output: BECRUDAgent, FECRUDAgent, UICRUDAgent classes extending BaseCRUDAgent.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/15-agent-orchestration/15-RESEARCH.md
@.planning/phases/15-agent-orchestration/15-CONTEXT.md
@.planning/phases/14-template-system/14-05-SUMMARY.md
@.planning/phases/14-template-system/14-06-SUMMARY.md
@.planning/phases/14-template-system/14-07-SUMMARY.md
@packages/agent-orchestrator/src/agents/BaseCRUDAgent.ts
@packages/agent-orchestrator/src/agents/types.ts
@packages/template-engine/package.json
</context>

<tasks>

<task type="auto">
  <name>Implement BECRUDAgent</name>
  <files>packages/agent-orchestrator/src/agents/BECRUDAgent.ts</files>
  <action>
    Create BECRUDAgent extending BaseCRUDAgent:

    ```typescript
    // @convex-poc/agent-orchestrator/agents/BECRUDAgent - Backend CRUD APIs agent

    import { join } from "path";
    import type { CRUDAgentConfig, type TableDefinition, type TemplateType } from "./types.js";
    import { pascalCase, camelCase } from "@convex-poc/template-engine/engine";

    /**
     * BECRUDAgent generates backend CRUD code for a single table.
     *
     * Spawns N sub-tasks (one per table), each generating:
     * - types.ts: TypeScript interfaces for table model
     * - sql.ts: SQL queries (findMany, findById, create, update, delete, count)
     * - index.ts: Repository class with CRUD methods
     * - README.md: Usage documentation
     * - index.http: HTTP requests for testing (VS Code REST Client)
     *
     * Templates: .templates/be/crud/* (from Phase 14-05)
     */
    export class BECRUDAgent extends BaseCRUDAgent {
      constructor(config: CRUDAgentConfig) {
        super(config);
      }

      /**
       * Selects template based on table name.
       * Templates from Phase 14-05:
       * - types.ts.hbs
       * - sql.ts.hbs
       * - index.ts.hbs
       * - README.md.hbs
       * - index.http.hbs
       */
      protected selectTemplate(table?: TableDefinition): string {
        if (!table) throw new Error("BECRUDAgent requires table definition");
        return "be/crud";
      }

      /**
       * Prepares template variables for CRUD code generation.
       *
       * Variables from Phase 14-05 templates:
       * - tableName: Original table name (e.g., "students")
       * - TableName: Pascal case (e.g., "Students")
       * - columns: Array of column definitions
       * - primaryKeys: Array of primary key column names
       * - foreignKeys: Array of foreign key constraints
       * - indexes: Array of index definitions
       */
      protected async prepareTemplateVariables(table?: TableDefinition): Promise<Record<string, unknown>> {
        if (!table) throw new Error("BECRUDAgent requires table definition");

        return {
          tableName: table.tableName,
          TableName: pascalCase(table.tableName),
          table: table,
          columns: table.columns,
          primaryKeys: table.columns.filter(c => c.isPrimaryKey).map(c => c.name),
          foreignKeys: table.foreignKeys || [],
          indexes: table.indexes || [],
          // Helper functions for templates
          pascalCase,
          camelCase,
        };
      }

      /**
       * Returns output path for generated CRUD files.
       * Format: workspacePath/src/repositories/{tableName}/
       */
      protected getOutputPath(table?: TableDefinition): string {
        if (!table) throw new Error("BECRUDAgent requires table definition");
        return join(this.config.workspacePath, "src", "repositories", table.tableName);
      }

      /**
       * Generates all CRUD files for a single table.
       */
      async execute(table?: TableDefinition): Promise<void> {
        if (!table) throw new Error("BECRUDAgent requires table definition");

        const { totalSteps } = this.config;

        try {
          // Step 1: Load templates (5 files)
          await this.updateProgress(1, `Loading CRUD templates for ${table.tableName}`);

          const templateFiles = [
            "types.ts.hbs",
            "sql.ts.hbs",
            "index.ts.hbs",
            "README.md.hbs",
            "index.http.hbs",
          ];

          const templates = await Promise.all(
            templateFiles.map(file =>
              this.templateEngine.load(`be/crud/${file}`)
            )
          );

          // Step 2: Prepare variables
          await this.updateProgress(2, `Preparing variables for ${table.tableName}`);
          const variables = await this.prepareTemplateVariables(table);

          // Step 3: Generate code
          await this.updateProgress(3, `Generating CRUD code for ${table.tableName}`);

          const outputPath = this.getOutputPath(table);
          const generatedFiles = templates.map((template, index) => ({
            template,
            outputPath: join(outputPath, templateFiles[index].replace(".hbs", "")),
            variables,
          }));

          // Step 4: Write files with locking
          await this.updateProgress(4, `Writing CRUD files for ${table.tableName}`);

          for (const { template, outputPath, variables } of generatedFiles) {
            const code = this.templateEngine.render(template, variables);
            await this.writeWithLock(table, code, outputPath);
          }

          // Step 5: Complete
          await this.updateProgress(
            totalSteps,
            `CRUD APIs generated for ${table.tableName}`,
            "done"
          );

        } catch (error) {
          await this.handleExecutionError(table.tableName, error);
        }
      }

      /**
       * Overridden writeWithLock for custom output paths.
       */
      protected async writeWithLock(
        table: TableDefinition | undefined,
        content: string,
        customPath?: string
      ): Promise<void> {
        const outputPath = customPath || this.getOutputPath(table);

        await require("fs/promises").mkdir(
          require("path").dirname(outputPath),
          { recursive: true }
        );

        await this.lockManager.withLock(outputPath, async () => {
          await require("fs/promises").writeFile(outputPath, content, "utf-8");
        });
      }
    }
    ```

    Reference Phase 14-05 templates for exact variable names.
  </action>
  <verify>grep -q "class BECRUDAgent" packages/agent-orchestrator/src/agents/BECRUDAgent.ts</verify>
  <done>BECRUDAgent implemented with 5-file CRUD generation per table (types.ts, sql.ts, index.ts, README.md, index.http)</done>
</task>

<task type="auto">
  <name>Implement FECRUDAgent</name>
  <files>packages/agent-orchestrator/src/agents/FECRUDAgent.ts</files>
  <action>
    Create FECRUDAgent extending BaseCRUDAgent:

    ```typescript
    // @convex-poc/agent-orchestrator/agents/FECRUDAgent - Frontend CRUD services agent

    import { join } from "path";
    import type { CRUDAgentConfig, type TableDefinition } from "./types.js";
    import { pascalCase, camelCase } from "@convex-poc/template-engine/engine";

    /**
     * FECRUDAgent generates frontend service code for a single table.
     *
     * Spawns N sub-tasks (one per table), each generating:
     * - types.ts: TypeScript interfaces matching backend DTOs
     * - api.ts: Fetch API wrapper with error handling
     * - hooks.ts: TanStack Query hooks (useQuery, useMutation)
     * - index.ts: Barrel export
     * - README.md: Usage documentation
     *
     * Templates: .templates/fe/crud/* (from Phase 14-06)
     */
    export class FECRUDAgent extends BaseCRUDAgent {
      constructor(config: CRUDAgentConfig) {
        super(config);
      }

      protected selectTemplate(table?: TableDefinition): string {
        if (!table) throw new Error("FECRUDAgent requires table definition");
        return "fe/crud";
      }

      /**
       * Prepares template variables for frontend service generation.
       *
       * Variables from Phase 14-06 templates:
       * - tableName, TableName: Table name variants
       * - columns: Column definitions for type generation
       * - apiUrl: Base URL for API requests (from VITE_API_URL env var)
       * - queryKeys: Query key factory pattern
       */
      protected async prepareTemplateVariables(table?: TableDefinition): Promise<Record<string, unknown>> {
        if (!table) throw new Error("FECRUDAgent requires table definition");

        return {
          tableName: table.tableName,
          TableName: pascalCase(table.tableName),
          table: table,
          columns: table.columns,
          primaryKeys: table.columns.filter(c => c.isPrimaryKey).map(c => c.name),
          apiUrl: "import.meta.env.VITE_API_URL || 'http://localhost:3000'",
          pascalCase,
          camelCase,
        };
      }

      /**
       * Returns output path for generated service files.
       * Format: workspacePath/src/services/{tableName}/
       */
      protected getOutputPath(table?: TableDefinition): string {
        if (!table) throw new Error("FECRUDAgent requires table definition");
        return join(this.config.workspacePath, "src", "services", table.tableName);
      }

      /**
       * Generates all service files for a single table.
       */
      async execute(table?: TableDefinition): Promise<void> {
        if (!table) throw new Error("FECRUDAgent requires table definition");

        const { totalSteps } = this.config;

        try {
          // Step 1: Load templates (5 files)
          await this.updateProgress(1, `Loading service templates for ${table.tableName}`);

          const templateFiles = [
            "types.ts.hbs",
            "api.ts.hbs",
            "hooks.ts.hbs",
            "index.ts.hbs",
            "README.md.hbs",
          ];

          const templates = await Promise.all(
            templateFiles.map(file =>
              this.templateEngine.load(`fe/crud/${file}`)
            )
          );

          // Step 2: Prepare variables
          await this.updateProgress(2, `Preparing variables for ${table.tableName}`);
          const variables = await this.prepareTemplateVariables(table);

          // Step 3: Generate code
          await this.updateProgress(3, `Generating service code for ${table.tableName}`);

          const outputPath = this.getOutputPath(table);
          const generatedFiles = templates.map((template, index) => ({
            template,
            outputPath: join(outputPath, templateFiles[index].replace(".hbs", "")),
            variables,
          }));

          // Step 4: Write files
          await this.updateProgress(4, `Writing service files for ${table.tableName}`);

          for (const { template, outputPath, variables } of generatedFiles) {
            const code = this.templateEngine.render(template, variables);
            await this.writeWithLock(table, code, outputPath);
          }

          // Step 5: Complete
          await this.updateProgress(
            totalSteps,
            `CRUD services generated for ${table.tableName}`,
            "done"
          );

        } catch (error) {
          await this.handleExecutionError(table.tableName, error);
        }
      }

      protected async writeWithLock(
        table: TableDefinition | undefined,
        content: string,
        customPath?: string
      ): Promise<void> {
        const outputPath = customPath || this.getOutputPath(table);

        await require("fs/promises").mkdir(
          require("path").dirname(outputPath),
          { recursive: true }
        );

        await this.lockManager.withLock(outputPath, async () => {
          await require("fs/promises").writeFile(outputPath, content, "utf-8");
        });
      }
    }
    ```

    Reference Phase 14-06 templates for exact variable names.
  </action>
  <verify>grep -q "class FECRUDAgent" packages/agent-orchestrator/src/agents/FECRUDAgent.ts</verify>
  <done>FECRUDAgent implemented with 5-file service generation per table (types.ts, api.ts, hooks.ts, index.ts, README.md)</done>
</task>

<task type="auto">
  <name>Implement UICRUDAgent</name>
  <files>packages/agent-orchestrator/src/agents/UICRUDAgent.ts</files>
  <action>
    Create UICRUDAgent extending BaseCRUDAgent:

    ```typescript
    // @convex-poc/agent-orchestrator/agents/UICRUDAgent - UI CRUD pages agent

    import { join } from "path";
    import type { CRUDAgentConfig, type TableDefinition } from "./types.js";
    import { pascalCase, camelCase } from "@convex-poc/template-engine/engine";

    /**
     * UICRUDAgent generates UI CRUD components for a single table.
     *
     * Spawns N sub-tasks (one per table), each generating:
     * - Page.tsx: Main page with list, create, edit views
     * - schema.ts: Zod validation schema from table columns
     * - form.tsx: React Hook Form with validation
     * - table.tsx: Table component with edit/delete actions
     * - hooks.ts: Custom hooks for form and table state
     * - README.md: Usage documentation
     *
     * Templates: .templates/ui/crud/* (from Phase 14-07)
     */
    export class UICRUDAgent extends BaseCRUDAgent {
      constructor(config: CRUDAgentConfig) {
        super(config);
      }

      protected selectTemplate(table?: TableDefinition): string {
        if (!table) throw new Error("UICRUDAgent requires table definition");
        return "ui/crud";
      }

      /**
       * Prepares template variables for UI component generation.
       *
       * Variables from Phase 14-07 templates:
       * - tableName, TableName: Table name variants
       * - columns: Column definitions with HTML input type mapping
       * - formFields: Form field definitions with validation
       * - tableColumns: Table column definitions with display formatters
       */
      protected async prepareTemplateVariables(table?: TableDefinition): Promise<Record<string, unknown>> {
        if (!table) throw new Error("UICRUDAgent requires table definition");

        // Map PostgreSQL types to HTML input types
        const inputTypeMap: Record<string, string> = {
          "integer": "number",
          "bigint": "number",
          "decimal": "number",
          "numeric": "number",
          "varchar": "text",
          "text": "textarea",
          "boolean": "checkbox",
          "timestamp": "datetime-local",
          "date": "date",
          "jsonb": "textarea",
          "uuid": "text",
        };

        return {
          tableName: table.tableName,
          TableName: pascalCase(table.tableName),
          table: table,
          columns: table.columns,
          formFields: table.columns.map(col => ({
            name: col.name,
            label: pascalCase(col.name),
            type: inputTypeMap[col.type] || "text",
            required: !col.nullable,
            defaultValue: col.defaultValue,
          })),
          tableColumns: table.columns.slice(0, 6).map(col => ({
            name: col.name,
            label: pascalCase(col.name),
            type: col.type,
          })),
          pascalCase,
          camelCase,
        };
      }

      /**
       * Returns output path for generated UI files.
       * Format: workspacePath/src/pages/{tableName}/
       */
      protected getOutputPath(table?: TableDefinition): string {
        if (!table) throw new Error("UICRUDAgent requires table definition");
        return join(this.config.workspacePath, "src", "pages", table.tableName);
      }

      /**
       * Generates all UI files for a single table.
       */
      async execute(table?: TableDefinition): Promise<void> {
        if (!table) throw new Error("UICRUDAgent requires table definition");

        const { totalSteps } = this.config;

        try {
          // Step 1: Load templates (6 files)
          await this.updateProgress(1, `Loading UI templates for ${table.tableName}`);

          const templateFiles = [
            "Page.tsx.hbs",
            "schema.ts.hbs",
            "form.tsx.hbs",
            "table.tsx.hbs",
            "hooks.ts.hbs",
            "README.md.hbs",
          ];

          const templates = await Promise.all(
            templateFiles.map(file =>
              this.templateEngine.load(`ui/crud/${file}`)
            )
          );

          // Step 2: Prepare variables
          await this.updateProgress(2, `Preparing variables for ${table.tableName}`);
          const variables = await this.prepareTemplateVariables(table);

          // Step 3: Generate code
          await this.updateProgress(3, `Generating UI components for ${table.tableName}`);

          const outputPath = this.getOutputPath(table);
          const generatedFiles = templates.map((template, index) => ({
            template,
            outputPath: join(outputPath, templateFiles[index].replace(".hbs", "")),
            variables,
          }));

          // Step 4: Write files
          await this.updateProgress(4, `Writing UI files for ${table.tableName}`);

          for (const { template, outputPath, variables } of generatedFiles) {
            const code = this.templateEngine.render(template, variables);
            await this.writeWithLock(table, code, outputPath);
          }

          // Step 5: Complete
          await this.updateProgress(
            totalSteps,
            `UI pages generated for ${table.tableName}`,
            "done"
          );

        } catch (error) {
          await this.handleExecutionError(table.tableName, error);
        }
      }

      protected async writeWithLock(
        table: TableDefinition | undefined,
        content: string,
        customPath?: string
      ): Promise<void> {
        const outputPath = customPath || this.getOutputPath(table);

        await require("fs/promises").mkdir(
          require("path").dirname(outputPath),
          { recursive: true }
        );

        await this.lockManager.withLock(outputPath, async () => {
          await require("fs/promises").writeFile(outputPath, content, "utf-8");
        });
      }
    }
    ```

    Reference Phase 14-07 templates for exact variable names.
  </action>
  <verify>grep -q "class UICRUDAgent" packages/agent-orchestrator/src/agents/UICRUDAgent.ts</verify>
  <done>UICRUDAgent implemented with 6-file UI generation per table (Page.tsx, schema.ts, form.tsx, table.tsx, hooks.ts, README.md)</done>
</task>

<task type="auto">
  <name>Update agents barrel export</name>
  <files>packages/agent-orchestrator/src/agents/index.ts</files>
  <action>
    Update agents/index.ts to export all CRUD agents:

    ```typescript
    // @convex-poc/agent-orchestrator/agents - Agent exports

    export { BaseCRUDAgent } from "./BaseCRUDAgent.js";
    export { BEBoilerplateAgent } from "./BEBoilerplateAgent.js";
    export { FEBoilerplateAgent } from "./FEBoilerplateAgent.js";
    export { BECRUDAgent } from "./BECRUDAgent.js";
    export { FECRUDAgent } from "./FECRUDAgent.js";
    export { UICRUDAgent } from "./UICRUDAgent.js";
    export * from "./types.js";
    ```
  </action>
  <verify>grep -q "BECRUDAgent\|FECRUDAgent\|UICRUDAgent" packages/agent-orchestrator/src/agents/index.ts</verify>
  <done>Agents module exports all 5 CRUD agents (BE/FE boilerplate, BE CRUD, FE CRUD, UI CRUD)</done>
</task>

</tasks>

<verification>
# Post-Execution Verification

## Build Check
- Run: `pnpm --filter @convex-poc/agent-orchestrator build`
- Expected: Clean compilation

## Template Check
```bash
ls .templates/be/crud/
# Expected: types.ts.hbs, sql.ts.hbs, index.ts.hbs, README.md.hbs, index.http.hbs

ls .templates/fe/crud/
# Expected: types.ts.hbs, api.ts.hbs, hooks.ts.hbs, index.ts.hbs, README.md.hbs

ls .templates/ui/crud/
# Expected: Page.tsx.hbs, schema.ts.hbs, form.tsx.hbs, table.tsx.hbs, hooks.ts.hbs, README.md.hbs
```

## Type Check
- All 3 CRUD agents extend BaseCRUDAgent
- All require table definition (not undefined)
- All override selectTemplate, prepareTemplateVariables, getOutputPath, execute
</verification>

<success_criteria>
1. BECRUDAgent generates 5 files per table using Phase 14-05 templates
2. FECRUDAgent generates 5 files per table using Phase 14-06 templates
3. UICRUDAgent generates 6 files per table using Phase 14-07 templates
4. Each agent operates on a single table per sub-task
5. File locking prevents conflicts when multiple sub-tasks write simultaneously
</success_criteria>

<output>
After completion, create `.planning/phases/15-agent-orchestration/15-04-SUMMARY.md`
</output>
