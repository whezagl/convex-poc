---
phase: 15-agent-orchestration
plan: 06
type: execute
wave: 3
depends_on: ["15-01", "15-05"]
files_modified:
  - packages/agent-orchestrator/src/orchestrator/ParallelOrchestrator.ts
  - packages/agent-orchestrator/src/orchestrator/SubTaskManager.ts
  - packages/agent-orchestrator/src/orchestrator/index.ts
  - packages/agent-orchestrator/package.json
autonomous: true

must_haves:
  truths:
    - "ParallelOrchestrator executes tasks with max 5 concurrent limit"
    - "Sub-tasks execute in parallel up to 5 per parent task"
    - "Parent task status aggregates from sub-task statuses"
    - "Agent progress streams to Convex in real-time"
    - "File locks prevent write conflicts during parallel execution"
  artifacts:
    - path: "packages/agent-orchestrator/src/orchestrator/ParallelOrchestrator.ts"
      provides: "Parallel orchestrator coordinating agents, queues, and Convex"
      exports: ["ParallelOrchestrator"]
    - path: "packages/agent-orchestrator/src/orchestrator/SubTaskManager.ts"
      provides: "Sub-task spawning and coordination"
      exports: ["SubTaskManager"]
  key_links:
    - from: "ParallelOrchestrator.ts"
      to: "./queue/TaskQueue"
      via: "import { TaskQueue } from '../queue/TaskQueue.js'"
      pattern: "new TaskQueue|taskQueue\\.add"
    - from: "ParallelOrchestrator.ts"
      to: "./dispatcher/AgentDispatcher"
      via: "import { AgentDispatcher } from '../dispatcher/AgentDispatcher.js'"
      pattern: "dispatcher\\.classifyTask"
    - from: "ParallelOrchestrator.ts"
      to: "./agents"
      via: "import * as Agents from '../agents/index.js'"
      pattern: "new Agents\\.(BE|FE)CRUDAgent|BoilerplateAgent"
    - from: "ParallelOrchestrator.ts"
      to: "@convex-poc/convex-client"
      via: "import { convex } from '@convex-poc/convex-client'"
      pattern: "convex\\.mutations\\.(tasks|subtasks)"
---

<objective>
Build ParallelOrchestrator coordinating agents, queues, and Convex for parallel task execution.

Purpose: Replace SequentialOrchestrator with parallel execution, supporting CRUD agents, sub-task spawning, priority queues, and real-time Convex progress tracking.

Output: ParallelOrchestrator class with executeTask, spawnSubTasks, coordinateExecution methods and SubTaskManager helper class.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/15-agent-orchestration/15-RESEARCH.md
@.planning/phases/15-agent-orchestration/15-CONTEXT.md
@packages/agent-orchestrator/src/queue/TaskQueue.ts
@packages/agent-orchestrator/src/dispatcher/AgentDispatcher.ts
@packages/agent-orchestrator/src/agents/index.ts
@packages/shared-types/src/task.ts
@packages/shared-types/src/subtask.ts
@convex/schema.ts
@src/orchestrator/SequentialOrchestrator.ts
</context>

<tasks>

<task type="auto">
  <name>Implement SubTaskManager</name>
  <files>packages/agent-orchestrator/src/orchestrator/SubTaskManager.ts</files>
  <action>
    Create SubTaskManager class:

    ```typescript
    // @convex-poc/agent-orchestrator/orchestrator/SubTaskManager - Sub-task coordination

    import type { Id } from "@convex-poc/shared-types/subtask";
    import type { AgentType } from "@convex-poc/shared-types/agent";
    import { convex } from "@convex-poc/convex-client";
    import { TaskQueue } from "../queue/TaskQueue.js";
    import type { TableDefinition } from "../agents/types.js";

    /**
     * SubTaskManager coordinates sub-task spawning and execution.
     *
     * Responsibilities:
     * - Create N sub-tasks in Convex (one per table for CRUD agents)
     * - Execute sub-tasks in parallel with max 5 concurrent
     * - Track aggregate progress and update parent task status
     * - Handle sub-task failures with proper error propagation
     */
    export class SubTaskManager {
      private readonly subTaskQueue: TaskQueue;
      private readonly parentTaskId: Id;
      private readonly workspacePath: string;
      private readonly ddlPath?: string;

      constructor(config: {
        parentTaskId: Id;
        workspacePath: string;
        ddlPath?: string;
      }) {
        this.parentTaskId = config.parentTaskId;
        this.workspacePath = config.workspacePath;
        this.ddlPath = config.ddlPath;

        // Create sub-task queue with max 5 concurrent
        this.subTaskQueue = new TaskQueue({
          concurrency: 5,
          autoStart: true,
          timeout: 300000, // 5 minutes per sub-task
        });
      }

      /**
       * Spawns sub-tasks for CRUD operations (one per table).
       *
       * @param tables - Array of table definitions
       * @param agentType - Agent type for all sub-tasks
       * @returns Array of created sub-task IDs
       */
      async spawnSubTasks(
        tables: TableDefinition[],
        agentType: AgentType
      ): Promise<Id[]> {
        // Create sub-tasks in Convex (batch insert)
        const subTasks = await Promise.all(
          tables.map((table, index) =>
            convex.mutations.subtasks.create({
              taskId: this.parentTaskId,
              title: `${agentType}: ${table.tableName}`,
              status: "pending",
              agentType,
              stepNumber: 0,
              totalSteps: 5, // Standard 5-step workflow
              createdAt: Date.now(),
              updatedAt: Date.now(),
            })
          )
        );

        console.log(
          `[SubTaskManager] Spawned ${subTasks.length} sub-tasks for ${agentType}`
        );

        return subTasks;
      }

      /**
       * Executes sub-tasks in parallel using TaskQueue.
       *
       * @param subTaskIds - Array of sub-task IDs
       * @param tables - Array of table definitions (same order as subTaskIds)
       * @param agentFactory - Factory function to create agent instances
       */
      async executeSubTasks(
        subTaskIds: Id[],
        tables: TableDefinition[],
        agentFactory: (subTaskId: Id, table: TableDefinition) => Promise<void>
      ): Promise<void> {
        if (subTaskIds.length !== tables.length) {
          throw new Error("Sub-task count must match table count");
        }

        // Add all sub-tasks to queue (parallel execution)
        const tasks = subTaskIds.map((subTaskId, index) => ({
          taskFn: () => agentFactory(subTaskId, tables[index]),
          options: {
            taskId: subTaskId,
            priority: 5, // Medium priority for CRUD sub-tasks
          },
        }));

        // Execute with progress tracking
        await this.subTaskQueue.addMany(tasks);

        // Wait for all sub-tasks to complete
        await this.subTaskQueue.onIdle();

        // Update parent task status
        await this.updateParentTaskStatus();
      }

      /**
       * Executes boilerplate sub-task (single sub-task, no tables).
       *
       * @param agentType - Agent type (BE/FE Boilerplate)
       * @param agentFactory - Factory function to create agent instance
       */
      async executeBoilerplateSubTask(
        agentType: AgentType,
        agentFactory: (subTaskId: Id) => Promise<void>
      ): Promise<void> {
        // Create single sub-task
        const [subTaskId] = await convex.mutations.subtasks.create({
          taskId: this.parentTaskId,
          title: `${agentType}: Project setup`,
          status: "pending",
          agentType,
          stepNumber: 0,
          totalSteps: 5,
          createdAt: Date.now(),
          updatedAt: Date.now(),
        });

        console.log(`[SubTaskManager] Spawned boilerplate sub-task: ${subTaskId}`);

        // Execute sub-task
        await this.subTaskQueue.add(agentFactory, {
          taskId: subTaskId,
          priority: 10, // High priority for boilerplate
        });

        // Wait for completion
        await this.subTaskQueue.onIdle();

        // Update parent task status
        await this.updateParentTaskStatus();
      }

      /**
       * Updates parent task status based on sub-task completion.
       * Aggregates sub-task statuses and updates Convex.
       */
      private async updateParentTaskStatus(): Promise<void> {
        // Fetch all sub-tasks for parent task
        const subTasks = await convex.queries.subtasks.listByTask({
          taskId: this.parentTaskId,
        });

        if (!subTasks) {
          console.warn(`[SubTaskManager] No sub-tasks found for parent ${this.parentTaskId}`);
          return;
        }

        // Calculate aggregate status
        const total = subTasks.length;
        const done = subTasks.filter(st => st.status === "done").length;
        const failed = subTasks.filter(st => st.status === "failed").length;
        const running = subTasks.filter(st => st.status === "running").length;

        let parentStatus: "pending" | "running" | "done" | "failed";
        if (done === total) {
          parentStatus = failed > 0 ? "failed" : "done";
        } else if (running > 0 || done > 0) {
          parentStatus = "running";
        } else {
          parentStatus = "pending";
        }

        // Update parent task in Convex
        await convex.mutations.tasks.updateStatus({
          taskId: this.parentTaskId,
          status: parentStatus,
          subTaskIds: subTasks.map(st => st._id),
          progress: {
            completed: done,
            total,
            failed,
          },
          updatedAt: Date.now(),
        });

        console.log(
          `[SubTaskManager] Parent task status: ${parentStatus} (${done}/${total} sub-tasks done)`
        );
      }

      /**
       * Gets queue statistics for monitoring.
       */
      getQueueStats() {
        return this.subTaskQueue.getStats();
      }

      /**
       * Cleans up resources (queues, locks).
       */
      async cleanup(): Promise<void> {
        this.subTaskQueue.clear();
      }
    }
    ```

    Export from orchestrator/index.ts
  </action>
  <verify>grep -q "class SubTaskManager" packages/agent-orchestrator/src/orchestrator/SubTaskManager.ts</verify>
  <done>SubTaskManager implemented with spawnSubTasks, executeSubTasks, executeBoilerplateSubTask, updateParentTaskStatus methods</done>
</task>

<task type="auto">
  <name>Implement ParallelOrchestrator</name>
  <files>packages/agent-orchestrator/src/orchestrator/ParallelOrchestrator.ts</files>
  <action>
    Create ParallelOrchestrator class:

    ```typescript
    // @convex-poc/agent-orchestrator/orchestrator/ParallelOrchestrator - Parallel task orchestration

    import type { Id } from "@convex-poc/shared-types/task";
    import type { AgentType } from "@convex-poc/shared-types/agent";
    import { convex } from "@convex-poc/convex-client";
    import { TaskQueue } from "../queue/TaskQueue.js";
    import { AgentDispatcher } from "../dispatcher/AgentDispatcher.js";
    import * as Agents from "../agents/index.js";
    import { SubTaskManager } from "./SubTaskManager.js";
    import { parseDDL } from "@convex-poc/template-engine/parser";
    import type { TableDefinition } from "../agents/types.js";

    /**
     * ParallelOrchestrator coordinates multi-agent task execution with parallel sub-tasks.
     *
     * Replaces SequentialOrchestrator with:
     * - Priority-based task queue (max 5 concurrent tasks)
     * - Keyword-based agent routing with LLM fallback
     * - Sub-task spawning (N sub-tasks for CRUD operations)
     * - Real-time Convex progress streaming
     * - File locking for parallel writes
     *
     * Workflow:
     * 1. Classify task description â†’ Agent type
     * 2. Spawn appropriate sub-tasks (1 for boilerplate, N for CRUD)
     * 3. Execute sub-tasks in parallel with concurrency limits
     * 4. Track progress in Convex for real-time UI updates
     */
    export class ParallelOrchestrator {
      private readonly taskQueue: TaskQueue;
      private readonly dispatcher: AgentDispatcher;

      constructor(config?: {
        dispatcher?: {
          apiKey?: string;
          enableLLM?: boolean;
        };
      }) {
        // Create task queue with max 5 concurrent tasks
        this.taskQueue = new TaskQueue({
          concurrency: 5,
          autoStart: true,
          timeout: 600000, // 10 minutes per task (boilerplate takes longer)
        });

        // Create agent dispatcher
        this.dispatcher = new AgentDispatcher({
          llmConfig: config?.dispatcher?.apiKey
            ? { apiKey: config.dispatcher.apiKey }
            : undefined,
          enableLLM: config?.dispatcher?.enableLLM ?? true,
        });

        console.log("[ParallelOrchestrator] Initialized with max 5 concurrent tasks");
      }

      /**
       * Executes a task with parallel sub-task coordination.
       *
       * @param taskInput - Task input with description, workspace, DDL path
       * @returns Task execution result
       */
      async executeTask(taskInput: {
        description: string;
        workspacePath: string;
        ddlPath?: string;
        priority?: number; // 1-10, default 5
      }): Promise<{
        success: boolean;
        taskId: Id;
        subTaskCount: number;
      }> {
        const { description, workspacePath, ddlPath, priority = 5 } = taskInput;

        console.log(`[ParallelOrchestrator] Executing task: ${description}`);

        // Step 1: Create task in Convex
        const taskId = await convex.mutations.tasks.create({
          title: description,
          description,
          status: "pending",
          priority: this.mapPriority(priority),
          workspacePath,
          createdAt: Date.now(),
          updatedAt: Date.now(),
        });

        console.log(`[ParallelOrchestrator] Created task: ${taskId}`);

        // Step 2: Classify task to determine agent type
        const classification = await this.dispatcher.classifyTask(description, taskId);
        console.log(
          `[ParallelOrchestrator] Classified as ${classification.agentType} (confidence: ${classification.confidence})`
        );

        // Step 3: Add task to queue for execution
        await this.taskQueue.add(
          () => this.coordinateExecution(taskId, classification.agentType, workspacePath, ddlPath),
          { taskId, priority }
        );

        return {
          success: true,
          taskId,
          subTaskCount: 0, // Will be updated by coordinateExecution
        };
      }

      /**
       * Coordinates task execution with sub-task spawning and agent coordination.
       *
       * @param taskId - Task ID
       * @param agentType - Determined agent type
       * @param workspacePath - Workspace path for code generation
       * @param ddlPath - Optional DDL path for CRUD operations
       */
      private async coordinateExecution(
        taskId: Id,
        agentType: AgentType,
        workspacePath: string,
        ddlPath?: string
      ): Promise<void> {
        console.log(`[ParallelOrchestrator] Coordinating ${agentType} for task ${taskId}`);

        try {
          // Update task status to running
          await convex.mutations.tasks.updateStatus({
            taskId,
            status: "running",
            updatedAt: Date.now(),
          });

          // Create sub-task manager
          const subTaskManager = new SubTaskManager({
            parentTaskId: taskId,
            workspacePath,
            ddlPath,
          });

          // Route to appropriate agent
          if (agentType === "BE Boilerplate" || agentType === "FE Boilerplate") {
            // Boilerplate: Spawn 1 sub-task
            await subTaskManager.executeBoilerplateSubTask(
              agentType,
              async (subTaskId: Id) => {
                const AgentClass = agentType === "BE Boilerplate"
                  ? Agents.BEBoilerplateAgent
                  : Agents.FEBoilerplateAgent;

                const agent = new AgentClass({
                  agentType,
                  subTaskId,
                  workspacePath,
                  templateType: agentType === "BE Boilerplate" ? "be/boilerplate" : "fe/boilerplate",
                  totalSteps: 5,
                });

                await agent.execute();
                await agent.cleanup();
              }
            );

          } else {
            // CRUD: Parse DDL and spawn N sub-tasks (one per table)
            if (!ddlPath) {
              throw new Error(`DDL path required for ${agentType}`);
            }

            const tables = await this.parseTables(ddlPath);
            console.log(`[ParallelOrchestrator] Parsed ${tables.length} tables from DDL`);

            const subTaskIds = await subTaskManager.spawnSubTasks(tables, agentType);

            // Execute sub-tasks with appropriate agent
            const AgentClass = this.getAgentClass(agentType);

            await subTaskManager.executeSubTasks(
              subTaskIds,
              tables,
              async (subTaskId: Id, table: TableDefinition) => {
                const agent = new AgentClass({
                  agentType,
                  subTaskId,
                  workspacePath,
                  ddlPath,
                  templateType: this.getTemplateType(agentType),
                  totalSteps: 5,
                });

                await agent.execute(table);
                await agent.cleanup();
              }
            );
          }

          // Cleanup
          await subTaskManager.cleanup();

          console.log(`[ParallelOrchestrator] Task ${taskId} completed successfully`);

        } catch (error) {
          console.error(`[ParallelOrchestrator] Task ${taskId} failed: ${error}`);

          // Update task status to failed
          await convex.mutations.tasks.updateStatus({
            taskId,
            status: "cancelled", // Using "cancelled" for failed tasks
            updatedAt: Date.now(),
          });

          throw error;
        }
      }

      /**
       * Parses DDL file to extract table definitions.
       */
      private async parseTables(ddlPath: string): Promise<TableDefinition[]> {
        const { readFile } = await import("fs/promises");
        const ddlContent = await readFile(ddlPath, "utf-8");
        const parseResult = parseDDL(ddlContent);

        if (!parseResult.success) {
          throw new Error(`DDL parsing failed: ${parseResult.errors.join(", ")}`);
        }

        return parseResult.tables;
      }

      /**
       * Gets agent class for agent type.
       */
      private getAgentClass(agentType: AgentType): typeof Agents.BECRUDAgent {
        switch (agentType) {
          case "BE CRUD APIs":
            return Agents.BECRUDAgent;
          case "FE CRUD Services":
            return Agents.FECRUDAgent;
          case "UI CRUD Pages":
            return Agents.UICRUDAgent;
          default:
            throw new Error(`Unknown CRUD agent type: ${agentType}`);
        }
      }

      /**
       * Gets template type for agent type.
       */
      private getTemplateType(agentType: AgentType): string {
        switch (agentType) {
          case "BE CRUD APIs":
            return "be/crud";
          case "FE CRUD Services":
            return "fe/crud";
          case "UI CRUD Pages":
            return "ui/crud";
          default:
            throw new Error(`Unknown CRUD agent type: ${agentType}`);
        }
      }

      /**
       * Maps priority number to Convex priority enum.
       */
      private mapPriority(priority: number): "low" | "medium" | "high" {
        if (priority >= 8) return "high";
        if (priority >= 4) return "medium";
        return "low";
      }

      /**
       * Gets queue statistics for monitoring.
       */
      getQueueStats() {
        return this.taskQueue.getStats();
      }

      /**
       * Waits for all tasks to complete.
       */
      async onIdle(): Promise<void> {
        return this.taskQueue.onIdle();
      }

      /**
       * Pauses task queue (no new tasks start).
       */
      pause(): void {
        this.taskQueue.pause();
      }

      /**
       * Starts task queue after pausing.
       */
      start(): void {
        this.taskQueue.start();
      }

      /**
       * Clears all pending tasks.
       */
      clear(): void {
        this.taskQueue.clear();
      }
    }
    ```

    Export from orchestrator/index.ts
  </action>
  <verify>grep -q "class ParallelOrchestrator" packages/agent-orchestrator/src/orchestrator/ParallelOrchestrator.ts</verify>
  <done>ParallelOrchestrator implemented with executeTask, coordinateExecution, and queue management methods</done>
</task>

<task type="auto">
  <name>Update orchestrator barrel export</name>
  <files>packages/agent-orchestrator/src/orchestrator/index.ts</files>
  <action>
    Update orchestrator/index.ts barrel export:

    ```typescript
    // @convex-poc/agent-orchestrator/orchestrator - Orchestrator exports

    export { ParallelOrchestrator } from "./ParallelOrchestrator.js";
    export { SubTaskManager } from "./SubTaskManager.js";
    ```

    Update package.json exports:

    ```json
    "exports": {
      "./orchestrator": "./src/orchestrator/index.ts",
      "./planner": "./src/planner.ts",
      "./coder": "./src/coder.ts",
      "./reviewer": "./src/reviewer.ts",
      "./queue": "./src/queue/index.ts",
      "./agents": "./src/agents/index.ts",
      "./dispatcher": "./src/dispatcher/index.ts",
      "./types/queue": "./src/types/queue.ts"
    }
    ```
  </action>
  <verify>cat packages/agent-orchestrator/src/orchestrator/index.ts</verify>
  <done>Orchestrator module exported with ParallelOrchestrator and SubTaskManager</done>
</task>

<task type="auto">
  <name>Add Convex mutations for task status updates</name>
  <files>convex/tasks.ts</files>
  <action>
    Add mutations for task status and sub-task creation:

    ```typescript
    import { mutation, query } from "./_generated/server";
    import { v } from "convex/values";

    // Create task
    export const create = mutation({
      args: {
        title: v.string(),
        description: v.optional(v.string()),
        status: v.union(
          v.literal("pending"),
          v.literal("running"),
          v.literal("paused"),
          v.literal("done"),
          v.literal("cancelled")
        ),
        priority: v.union(
          v.literal("low"),
          v.literal("medium"),
          v.literal("high")
        ),
        workspacePath: v.optional(v.string()),
        createdAt: v.number(),
        updatedAt: v.number(),
      },
      handler: async (ctx, args) => {
        const taskId = await ctx.db.insert("tasks", {
          title: args.title,
          description: args.description,
          status: args.status,
          priority: args.priority,
          workspacePath: args.workspacePath,
          subTaskIds: [],
          logs: [],
        });
        return taskId;
      },
    });

    // Update task status
    export const updateStatus = mutation({
      args: {
        taskId: v.id("tasks"),
        status: v.union(
          v.literal("pending"),
          v.literal("running"),
          v.literal("paused"),
          v.literal("done"),
          v.literal("cancelled")
        ),
        subTaskIds: v.optional(v.array(v.id("subtasks"))),
        progress: v.optional(v.object({
          completed: v.number(),
          total: v.number(),
          failed: v.optional(v.number()),
        })),
        updatedAt: v.number(),
      },
      handler: async (ctx, args) => {
        const { taskId, subTaskIds, progress, ...updates } = args;
        await ctx.db.patch(taskId, {
          ...updates,
          ...(subTaskIds && { subTaskIds }),
        });
      },
    });

    // List tasks by status
    export const listByStatus = query({
      args: {
        status: v.union(
          v.literal("pending"),
          v.literal("running"),
          v.literal("paused"),
          v.literal("done"),
          v.literal("cancelled")
        ),
      },
      handler: async (ctx, args) => {
        const tasks = await ctx.db
          .query("tasks")
          .withIndex("by_status", (q) => q.eq("status", args.status))
          .collect();
        return tasks;
      },
    });
    ```

    Add to convex/subtasks.ts:
    ```typescript
    // Create sub-task
    export const create = mutation({
      args: {
        taskId: v.id("tasks"),
        title: v.string(),
        status: v.union(
          v.literal("pending"),
          v.literal("running"),
          v.literal("done"),
          v.literal("failed")
        ),
        agentType: v.string(),
        stepNumber: v.number(),
        totalSteps: v.number(),
        createdAt: v.number(),
        updatedAt: v.number(),
      },
      handler: async (ctx, args) => {
        const subTaskId = await ctx.db.insert("subtasks", {
          taskId: args.taskId,
          title: args.title,
          status: args.status,
          agentType: args.agentType,
          stepNumber: args.stepNumber,
          totalSteps: args.totalSteps,
          logs: [],
        });
        return subTaskId;
      },
    });

    // Update sub-task progress
    export const updateProgress = mutation({
      args: {
        subTaskId: v.id("subtasks"),
        stepNumber: v.number(),
        totalSteps: v.number(),
        message: v.string(),
        status: v.optional(v.union(
          v.literal("running"),
          v.literal("done"),
          v.literal("failed")
        )),
        error: v.optional(v.string()),
        timestamp: v.number(),
      },
      handler: async (ctx, args) => {
        const { subTaskId, timestamp, ...updates } = args;
        await ctx.db.patch(subTaskId, {
          ...updates,
          updatedAt: timestamp,
        });
      },
    });

    // List sub-tasks by task
    export const listByTask = query({
      args: {
        taskId: v.id("tasks"),
      },
      handler: async (ctx, args) => {
        const subTasks = await ctx.db
          .query("subtasks")
          .withIndex("by_task", (q) => q.eq("taskId", args.taskId))
          .collect();
        return subTasks;
      },
    });
    ```
  </action>
  <verify>grep -q "export const create\|export const updateStatus" convex/tasks.ts</verify>
  <done>Convex mutations added for task creation, status updates, and sub-task management</done>
</task>

</tasks>

<verification>
# Post-Execution Verification

## Build Check
- Run: `pnpm --filter @convex-poc/agent-orchestrator build`
- Expected: Clean compilation

## Integration Test
```bash
node -e "
import { ParallelOrchestrator } from '@convex-poc/agent-orchestrator/orchestrator';

const orchestrator = new ParallelOrchestrator();

// Test task execution
const result = await orchestrator.executeTask({
  description: 'BE CRUD APIs for school management',
  workspacePath: '/tmp/test-workspace',
  ddlPath: './data/school-erp.ddl',
  priority: 7,
});

console.log('Task created:', result.taskId);
console.log('Queue stats:', orchestrator.getQueueStats());
"
```

## Queue Check
- Task queue configured with concurrency: 5
- Sub-task queue configured with concurrency: 5
- Both queues use priority scheduling
</verification>

<success_criteria>
1. ParallelOrchestrator executes tasks with max 5 concurrent limit
2. AgentDispatcher routes tasks to appropriate CRUD agents
3. SubTaskManager spawns and coordinates sub-tasks (1 for boilerplate, N for CRUD)
4. Real-time progress updates stream to Convex
5. File locking prevents write conflicts during parallel execution
6. Parent task status aggregates from sub-task statuses
</success_criteria>

<output>
After completion, create `.planning/phases/15-agent-orchestration/15-06-SUMMARY.md`
</output>
