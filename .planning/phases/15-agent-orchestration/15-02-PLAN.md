---
phase: 15-agent-orchestration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/agent-orchestrator/src/agents/BaseCRUDAgent.ts
  - packages/agent-orchestrator/src/agents/types.ts
  - packages/agent-orchestrator/src/agents/index.ts
autonomous: true

must_haves:
  truths:
    - "BaseCRUDAgent extends existing BaseAgent pattern with template integration"
    - "Agent progress updates stream to Convex in real-time"
    - "Template engine loads and renders Handlebars templates"
    - "File locking prevents write conflicts during parallel execution"
  artifacts:
    - path: "packages/agent-orchestrator/src/agents/BaseCRUDAgent.ts"
      provides: "Base class for CRUD agents with template integration"
      exports: ["BaseCRUDAgent", "CRUDAgentConfig"]
    - path: "packages/agent-orchestrator/src/agents/types.ts"
      provides: "Type definitions for CRUD agents"
      exports: ["TableDefinition", "TemplateType", "ProgressUpdate"]
  key_links:
    - from: "BaseCRUDAgent.ts"
      to: "@convex-poc/template-engine/engine"
      via: "import { TemplateEngine } from '@convex-poc/template-engine/engine'"
      pattern: "TemplateEngine\\.load|render"
    - from: "BaseCRUDAgent.ts"
      to: "@convex-poc/template-engine/parser"
      via: "import { parseDDL } from '@convex-poc/template-engine/parser'"
      pattern: "parseDDL"
    - from: "BaseCRUDAgent.ts"
      to: "@convex-poc/convex-client"
      via: "import { convex } from '@convex-poc/convex-client'"
      pattern: "convex\\.mutations"
    - from: "BaseCRUDAgent.ts"
      to: "./queue/FileLockManager"
      via: "import { FileLockManager } from '../queue/FileLockManager.js'"
      pattern: "lockManager\\.withLock"
---

<objective>
Create BaseCRUDAgent abstract class with template engine integration, Convex progress tracking, and file locking.

Purpose: Provide reusable base class for all CRUD agents (BE/FE boilerplate, CRUD APIs, services, UI pages) with common functionality: DDL parsing, template rendering, progress streaming, and safe file writes.

Output: BaseCRUDAgent abstract class with executeForTable, updateProgress, writeWithLock methods.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/15-agent-orchestration/15-RESEARCH.md
@.planning/phases/15-agent-orchestration/15-CONTEXT.md
@packages/agent-orchestrator/package.json
@packages/shared-types/src/agent.ts
@packages/shared-types/src/subtask.ts
@packages/template-engine/package.json
@src/agents/BaseAgent.ts
@src/agents/GLMBaseAgent.ts
</context>

<tasks>

<task type="auto">
  <name>Create CRUD agent type definitions</name>
  <files>packages/agent-orchestrator/src/agents/types.ts</files>
  <action>
    Create type definitions for CRUD agents:

    ```typescript
    // @convex-poc/agent-orchestrator/agents/types - CRUD agent type definitions

    import type { Id } from "@convex-poc/shared-types/subtask";
    import type { AgentType } from "@convex-poc/shared-types/agent";

    // Table definition from DDL parser
    export interface TableDefinition {
      tableName: string;
      columns: Array<{
        name: string;
        type: string;
        nullable: boolean;
        defaultValue?: string;
        isPrimaryKey?: boolean;
        isForeignKey?: boolean;
        references?: {
          table: string;
          column: string;
        };
      }>;
      foreignKeys?: Array<{
        columns: string[];
        references: {
          table: string;
          columns: string[];
        };
      }>;
      indexes?: Array<{
        name: string;
          columns: string[];
          unique?: boolean;
      }>;
    }

    // Template types matching Phase 14 templates
    export type TemplateType =
      | "be/boilerplate"      // Backend setup (1 sub-task)
      | "fe/boilerplate"      // Frontend setup (1 sub-task)
      | "be/crud"             // Backend CRUD APIs (N sub-tasks, one per table)
      | "fe/crud"             // Frontend services (N sub-tasks, one per table)
      | "ui/crud";            // UI CRUD pages (N sub-tasks, one per table)

    // CRUD agent configuration
    export interface CRUDAgentConfig {
      agentType: AgentType;
      subTaskId: Id;
      workspacePath: string;
      ddlPath?: string; // Optional: path to DDL file for CRUD agents
      templateType: TemplateType;
      totalSteps: number; // Expected steps (usually 5: parse, load, generate, format, write)
    }

    // Progress update for Convex streaming
    export interface ProgressUpdate {
      stepNumber: number;
      totalSteps: number;
      message: string;
      status?: "running" | "done" | "failed";
      error?: string;
    }

    // Template generation result
    export interface GenerationResult {
      tableName: string;
      templateType: TemplateType;
      files: Array<{
        path: string;
        content: string;
      }>;
      step: number;
      totalSteps: number;
    }
    ```

    Export from agents/index.ts
  </action>
  <verify>grep -q "interface CRUDAgentConfig" packages/agent-orchestrator/src/agents/types.ts</verify>
  <done>CRUD agent types defined with TableDefinition, CRUDAgentConfig, ProgressUpdate, TemplateType</done>
</task>

<task type="auto">
  <name>Implement BaseCRUDAgent abstract class</name>
  <files>packages/agent-orchestrator/src/agents/BaseCRUDAgent.ts</files>
  <action>
    Create BaseCRUDAgent abstract class:

    ```typescript
    // @convex-poc/agent-orchestrator/agents/BaseCRUDAgent - Base class for CRUD agents

    import { promises as fs } from "fs";
    import { join, dirname } from "path";
    import type { AgentType } from "@convex-poc/shared-types/agent";
    import { convex } from "@convex-poc/convex-client";
    import { TemplateEngine } from "@convex-poc/template-engine/engine";
    import { parseDDL } from "@convex-poc/template-engine/parser";
    import { FileLockManager } from "../queue/FileLockManager.js";
    import type {
      CRUDAgentConfig,
      TableDefinition,
      TemplateType,
      ProgressUpdate,
      GenerationResult,
    } from "./types.js";

    /**
     * BaseCRUDAgent provides common functionality for all CRUD agents:
     * - Template engine integration
     * - Convex progress streaming
     * - File locking for parallel writes
     * - DDL parsing for table-aware code generation
     */
    export abstract class BaseCRUDAgent {
      protected readonly config: CRUDAgentConfig;
      protected readonly lockManager: FileLockManager;
      protected readonly templateEngine: TemplateEngine;

      // Cache for parsed tables (avoid re-parsing DDL)
      private tablesCache?: TableDefinition[];

      constructor(config: CRUDAgentConfig) {
        this.config = config;
        this.lockManager = new FileLockManager();
        this.templateEngine = new TemplateEngine();
      }

      /**
       * Abstract method: Subclasses must implement template selection
       *
       * @param table - Table definition (for CRUD agents) or undefined (for boilerplate)
       * @returns Template name to load from .templates/ directory
       */
      protected abstract selectTemplate(
        table?: TableDefinition
      ): string;

      /**
       * Abstract method: Subclasses must implement template variable preparation
       *
       * @param table - Table definition (for CRUD agents) or undefined (for boilerplate)
       * @returns Variables object for template rendering
       */
      protected abstract prepareTemplateVariables(
        table?: TableDefinition
      ): Promise<Record<string, unknown>>;

      /**
       * Abstract method: Subclasses must implement output path resolution
       *
       * @param table - Table definition (for CRUD agents) or undefined (for boilerplate)
       * @returns Absolute path where generated code should be written
       */
      protected abstract getOutputPath(
        table?: TableDefinition
      ): string;

      /**
       * Executes the agent for a single table (or once for boilerplate agents).
       *
       * Workflow:
       * 1. Parse DDL to extract table structure (CRUD agents only)
       * 2. Load Handlebars template
       * 3. Prepare template variables
       * 4. Generate code with template
       * 5. Format with Biome (if applicable)
       * 6. Write to filesystem with file locking
       *
       * @param table - Optional table definition for CRUD agents
       */
      async execute(table?: TableDefinition): Promise<void> {
        const { subTaskId, templateType, totalSteps } = this.config;
        const targetName = table ? table.tableName : "project";

        try {
          // Step 1: Parse DDL (CRUD agents only)
          if (this.config.ddlPath && !table) {
            await this.updateProgress(1, `Parsing DDL from ${this.config.ddlPath}`);
            this.tablesCache = await this.parseDDL(this.config.ddlPath);
          } else {
            await this.updateProgress(1, `Starting ${this.config.agentType} for ${targetName}`);
          }

          // Step 2: Load template
          const templateName = this.selectTemplate(table);
          await this.updateProgress(2, `Loading template: ${templateName}`);
          const template = await this.templateEngine.load(templateName);

          // Step 3: Prepare variables
          await this.updateProgress(3, `Preparing variables for ${targetName}`);
          const variables = await this.prepareTemplateVariables(table);

          // Step 4: Generate code
          await this.updateProgress(4, `Generating code for ${targetName}`);
          const code = this.templateEngine.render(template, variables);

          // Step 5: Write to filesystem with lock
          await this.updateProgress(5, `Writing files for ${targetName}`);
          await this.writeWithLock(table, code);

          // Mark complete
          await this.updateProgress(totalSteps, `Completed ${this.config.agentType} for ${targetName}`, "done");

        } catch (error) {
          await this.handleExecutionError(targetName, error);
        }
      }

      /**
       * Executes the agent for multiple tables in parallel.
       * Used by CRUD agents that spawn N sub-tasks (one per table).
       *
       * @param tables - Array of table definitions
       */
      async executeForTables(tables: TableDefinition[]): Promise<void> {
        const results = await Promise.allSettled(
          tables.map(table => this.execute(table))
        );

        // Check for failures
        const failures = results.filter(r => r.status === "rejected");
        if (failures.length > 0) {
          throw new Error(
            `${failures.length} of ${tables.length} table operations failed`
          );
        }
      }

      /**
       * Parses DDL file to extract table definitions.
       * Results are cached to avoid re-parsing.
       *
       * @param ddlPath - Path to DDL file
       * @returns Array of table definitions
       */
      protected async parseDDL(ddlPath: string): Promise<TableDefinition[]> {
        if (this.tablesCache) {
          return this.tablesCache;
        }

        const ddlContent = await fs.readFile(ddlPath, "utf-8");
        const parseResult = parseDDL(ddlContent);

        if (!parseResult.success) {
          throw new Error(
            `DDL parsing failed: ${parseResult.errors.join(", ")}`
          );
        }

        this.tablesCache = parseResult.tables;
        return this.tablesCache;
      }

      /**
       * Writes generated code to filesystem with file locking.
       *
       * @param table - Optional table definition
       * @param content - Generated code content
       */
      protected async writeWithLock(
        table: TableDefinition | undefined,
        content: string
      ): Promise<void> {
        const outputPath = this.getOutputPath(table);

        // Ensure parent directory exists
        await fs.mkdir(dirname(outputPath), { recursive: true });

        // Write with lock to prevent conflicts in parallel execution
        await this.lockManager.withLock(outputPath, async () => {
          await fs.writeFile(outputPath, content, "utf-8");
        });
      }

      /**
       * Updates progress in Convex for real-time UI streaming.
       * Uses fire-and-forget pattern to avoid blocking agent execution.
       *
       * @param stepNumber - Current step number
       * @param message - Progress message
       * @param status - Optional status override
       */
      protected async updateProgress(
        stepNumber: number,
        message: string,
        status?: "running" | "done" | "failed"
      ): Promise<void> {
        const update: ProgressUpdate = {
          stepNumber,
          totalSteps: this.config.totalSteps,
          message,
          status,
        };

        // Non-blocking Convex update (don't await)
        convex.mutations.subtasks.updateProgress({
          subTaskId: this.config.subTaskId,
          ...update,
          timestamp: Date.now(),
        }).catch(err => {
          console.error(`[BaseCRUDAgent] Progress update failed: ${err}`);
        });
      }

      /**
       * Handles execution errors with proper Convex status update.
       *
       * @param targetName - Name of table/project being processed
       * @param error - Error object
       */
      protected async handleExecutionError(
        targetName: string,
        error: unknown
      ): Promise<void> {
        const errorMessage = error instanceof Error ? error.message : String(error);

        await this.updateProgress(
          this.config.totalSteps,
          `Failed ${this.config.agentType} for ${targetName}: ${errorMessage}`,
          "failed"
        );

        throw error;
      }

      /**
       * Cleans up resources (locks, connections).
       * Call this when agent is done (even if it failed).
       */
      async cleanup(): Promise<void> {
        await this.lockManager.releaseAll();
      }
    }
    ```

    Export from agents/index.ts
  </action>
  <verify>grep -q "class BaseCRUDAgent" packages/agent-orchestrator/src/agents/BaseCRUDAgent.ts</verify>
  <done>BaseCRUDAgent implemented with execute, executeForTables, parseDDL, writeWithLock, updateProgress methods</done>
</task>

<task type="auto">
  <name>Create agents barrel export</name>
  <files>packages/agent-orchestrator/src/agents/index.ts</files>
  <action>
    Create agents/index.ts barrel export:

    ```typescript
    // @convex-poc/agent-orchestrator/agents - Agent exports

    export { BaseCRUDAgent } from "./BaseCRUDAgent.js";
    export * from "./types.js";
    ```

    Update package.json exports:

    ```json
    "exports": {
      "./orchestrator": "./src/orchestrator.ts",
      "./planner": "./src/planner.ts",
      "./coder": "./src/coder.ts",
      "./reviewer": "./src/reviewer.ts",
      "./queue": "./src/queue/index.ts",
      "./agents": "./src/agents/index.ts",
      "./types/queue": "./src/types/queue.ts"
    }
    ```
  </action>
  <verify>cat packages/agent-orchestrator/src/agents/index.ts</verify>
  <done>Agents module exported with BaseCRUDAgent and types</done>
</task>

</tasks>

<verification>
# Post-Execution Verification

## Build Check
- Run: `pnpm --filter @convex-poc/agent-orchestrator build`
- Expected: Clean TypeScript compilation with no errors

## Import Check
```bash
node -e "
import('@convex-poc/agent-orchestrator/agents').then(m => {
  console.log('BaseCRUDAgent:', typeof m.BaseCRUDAgent);
})
"
```

## Type Check
- CRUDAgentConfig includes all required fields (agentType, subTaskId, workspacePath, templateType, totalSteps)
- TemplateType union includes all 5 template types
- TableDefinition matches DDL parser output structure
</verification>

<success_criteria>
1. BaseCRUDAgent is an abstract class (cannot be instantiated directly)
2. updateProgress method sends non-blocking updates to Convex
3. writeWithLock uses FileLockManager to prevent write conflicts
4. execute method follows 5-step workflow (parse, load, prepare, generate, write)
5. Template engine integration loads and renders Handlebars templates
</success_criteria>

<output>
After completion, create `.planning/phases/15-agent-orchestration/15-02-SUMMARY.md`
</output>
