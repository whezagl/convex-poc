---
phase: 15-agent-orchestration
plan: 05
type: execute
wave: 3
depends_on: ["15-01", "15-02", "15-03", "15-04"]
files_modified:
  - packages/agent-orchestrator/src/dispatcher/AgentDispatcher.ts
  - packages/agent-orchestrator/src/dispatcher/types.ts
  - packages/agent-orchestrator/src/dispatcher/index.ts
autonomous: true

must_haves:
  truths:
    - "AgentDispatcher routes tasks to appropriate agent based on keywords"
    - "Tasks route within 2 seconds when keywords match"
    - "LLM classifier handles ambiguous descriptions as fallback"
    - "Dispatcher stores classification result in Convex for debugging"
    - "All 5 CRUD agents are routable via keyword patterns"
  artifacts:
    - path: "packages/agent-orchestrator/src/dispatcher/AgentDispatcher.ts"
      provides: "Agent dispatcher with keyword routing and LLM fallback"
      exports: ["AgentDispatcher"]
    - path: "packages/agent-orchestrator/src/dispatcher/types.ts"
      provides: "Type definitions for agent routing"
      exports: ["AgentClassification", "KeywordPatterns"]
  key_links:
    - from: "AgentDispatcher.ts"
      to: "@convex-poc/shared-types/agent"
      via: "import type { AgentType } from '@convex-poc/shared-types/agent'"
      pattern: "AgentTypeSchema"
    - from: "AgentDispatcher.ts"
      to: "@anthropic-ai/sdk"
      via: "import { Client } from '@anthropic-ai/sdk'"
      pattern: "new Client|anthropic\\.messages\\.create"
    - from: "AgentDispatcher.ts"
      to: "@convex-poc/convex-client"
      via: "import { convex } from '@convex-poc/convex-client'"
      pattern: "convex\\.mutations\\.tasks\\.updateClassification"
---

<objective>
Build AgentDispatcher with keyword-based routing and LLM fallback for task classification.

Purpose: Analyze task descriptions and route to appropriate CRUD agent (BE/FE boilerplate, CRUD APIs, services, UI pages) using hybrid approach: keyword extraction first, LLM classification for ambiguous cases.

Output: AgentDispatcher class with classifyTask, extractKeywords, llmClassify methods.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/15-agent-orchestration/15-RESEARCH.md
@.planning/phases/15-agent-orchestration/15-CONTEXT.md
@packages/agent-orchestrator/src/agents/index.ts
@packages/shared-types/src/agent.ts
@packages/convex-client/package.json
</context>

<tasks>

<task type="auto">
  <name>Create dispatcher type definitions</name>
  <files>packages/agent-orchestrator/src/dispatcher/types.ts</files>
  <action>
    Create type definitions for agent routing:

    ```typescript
    // @convex-poc/agent-orchestrator/dispatcher/types - Dispatcher type definitions

    import type { AgentType } from "@convex-poc/shared-types/agent";

    /**
     * Agent classification result from keyword or LLM analysis.
     */
    export interface AgentClassification {
      agentType: AgentType;
      confidence: number; // 0.0 to 1.0
      keywords: string[]; // Matched keywords (keyword mode) or extracted phrases (LLM mode)
      method: "keyword" | "llm"; // Which method produced this result
      reasoning?: string; // LLM explanation (only if method: "llm")
    }

    /**
     * Keyword patterns for fast-path routing.
     * Maps agent type to array of matching phrases.
     */
    export type KeywordPatterns = Record<
      AgentType,
      string[]
    >;

    /**
     * LLM classifier configuration.
     */
    export interface LLMClassifierConfig {
      apiKey: string;
      model?: string; // Default: claude-3-haiku-20240307 (faster/cheaper)
      maxTokens?: number; // Default: 200
      temperature?: number; // Default: 0.3 (low temperature for classification)
    }

    /**
     * Dispatcher configuration.
     */
    export interface DispatcherConfig {
      keywordPatterns?: Partial<KeywordPatterns>; // Custom keyword patterns
      llmConfig?: LLMClassifierConfig; // LLM classifier settings
      enableLLM?: boolean; // Enable LLM fallback (default: true)
    }
    ```

    Export from dispatcher/index.ts
  </action>
  <verify>grep -q "interface AgentClassification" packages/agent-orchestrator/src/dispatcher/types.ts</verify>
  <done>Dispatcher types defined with AgentClassification, KeywordPatterns, LLMClassifierConfig, DispatcherConfig</done>
</task>

<task type="auto">
  <name>Implement AgentDispatcher</name>
  <files>packages/agent-orchestrator/src/dispatcher/AgentDispatcher.ts</files>
  <action>
    Create AgentDispatcher class:

    ```typescript
    // @convex-poc/agent-orchestrator/dispatcher/AgentDispatcher - Agent dispatcher with routing

    import { Client } from "@anthropic-ai/sdk";
    import type { AgentType } from "@convex-poc/shared-types/agent";
    import { convex } from "@convex-poc/convex-client";
    import type {
      AgentClassification,
      KeywordPatterns,
      LLMClassifierConfig,
      DispatcherConfig,
    } from "./types.js";

    /**
     * AgentDispatcher routes tasks to appropriate CRUD agents.
     *
     * Hybrid approach:
     * 1. Keyword extraction (fast path for ~80% of tasks)
     * 2. LLM classification (fallback for ambiguous descriptions)
     *
     * Classification results are stored in Convex for debugging and transparency.
     */
    export class AgentDispatcher {
      private readonly keywordPatterns: KeywordPatterns;
      private readonly llmClient?: Client;
      private readonly llmModel: string;
      private readonly enableLLM: boolean;

      constructor(config: DispatcherConfig = {}) {
        // Default keyword patterns from ROADMAP.md
        this.keywordPatterns = {
          "BE Boilerplate": config.keywordPatterns?.["BE Boilerplate"] || [
            "be setup",
            "backend setup",
            "backend boilerplate",
            "create backend",
            "setup backend project",
          ],
          "FE Boilerplate": config.keywordPatterns?.["FE Boilerplate"] || [
            "fe setup",
            "frontend setup",
            "frontend boilerplate",
            "create frontend",
            "setup frontend project",
          ],
          "BE CRUD APIs": config.keywordPatterns?.["BE CRUD APIs"] || [
            "be crud apis",
            "backend crud",
            "api generation",
            "generate backend apis",
            "create crud apis",
          ],
          "FE CRUD Services": config.keywordPatterns?.["FE CRUD Services"] || [
            "fe crud services",
            "frontend services",
            "service generation",
            "generate frontend services",
            "create crud services",
          ],
          "UI CRUD Pages": config.keywordPatterns?.["UI CRUD Pages"] || [
            "ui crud pages",
            "ui pages",
            "page generation",
            "generate ui pages",
            "create crud pages",
          ],
        };

        // Configure LLM client
        this.enableLLM = config.enableLLM ?? true;
        if (this.enableLLM && config.llmConfig?.apiKey) {
          this.llmClient = new Client({
            apiKey: config.llmConfig.apiKey,
          });
          this.llmModel = config.llmConfig.model || "claude-3-haiku-20240307";
        } else {
          this.llmClient = undefined;
          this.llmModel = "";
        }
      }

      /**
       * Classifies a task description and routes to appropriate agent.
       *
       * Workflow:
       * 1. Try keyword extraction (fast, high confidence if match)
       * 2. If no match, use LLM classifier (handles ambiguity)
       * 3. Store classification in Convex for debugging
       *
       * @param description - Task description from user
       * @param taskId - Optional task ID for Convex storage
       * @returns Agent classification with confidence and keywords
       */
      async classifyTask(
        description: string,
        taskId?: string
      ): Promise<AgentClassification> {
        // Step 1: Try keyword extraction (fast path)
        const keywordResult = this.extractKeywords(description);
        if (keywordResult && keywordResult.confidence > 0.8) {
          // High confidence keyword match - skip LLM
          await this.storeClassification(taskId, keywordResult);
          return keywordResult;
        }

        // Step 2: Use LLM classifier (fallback for ambiguous cases)
        if (this.enableLLM && this.llmClient) {
          try {
            const llmResult = await this.llmClassify(description);
            await this.storeClassification(taskId, llmResult);
            return llmResult;
          } catch (error) {
            console.error(`[AgentDispatcher] LLM classification failed: ${error}`);
            // Fall back to keyword result even if low confidence
            if (keywordResult) {
              await this.storeClassification(taskId, keywordResult);
              return keywordResult;
            }
          }
        }

        // Step 3: Default to first keyword match if available
        if (keywordResult) {
          await this.storeClassification(taskId, keywordResult);
          return keywordResult;
        }

        // Step 4: No match found - return default (BE Boilerplate)
        const defaultResult: AgentClassification = {
          agentType: "BE Boilerplate",
          confidence: 0.1,
          keywords: [],
          method: "keyword",
          reasoning: "No keywords matched, defaulting to BE Boilerplate",
        };
        await this.storeClassification(taskId, defaultResult);
        return defaultResult;
      }

      /**
       * Extracts keywords from task description.
       * Returns classification if keywords match an agent type.
       *
       * @param description - Task description
       * @returns Classification or null if no match
       */
      private extractKeywords(description: string): AgentClassification | null {
        const normalized = description.toLowerCase();
        const matchedKeywords: string[] = [];

        // Check each agent's keyword patterns
        for (const [agentType, patterns] of Object.entries(this.keywordPatterns)) {
          for (const pattern of patterns) {
            if (normalized.includes(pattern.toLowerCase())) {
              matchedKeywords.push(pattern);
            }
          }

          // If we found matches for this agent type
          if (matchedKeywords.length > 0) {
            return {
              agentType: agentType as AgentType,
              confidence: 0.9, // High confidence for keyword matches
              keywords: matchedKeywords,
              method: "keyword",
            };
          }
        }

        return null;
      }

      /**
       * Uses LLM to classify ambiguous task descriptions.
       *
       * @param description - Task description
       * @returns Classification from LLM
       */
      private async llmClassify(description: string): Promise<AgentClassification> {
        if (!this.llmClient) {
          throw new Error("LLM client not configured");
        }

        const prompt = this.buildClassificationPrompt(description);

        const response = await this.llmClient.messages.create({
          model: this.llmModel,
          max_tokens: 200,
          temperature: 0.3,
          messages: [
            {
              role: "user",
              content: prompt,
            },
          ],
        });

        // Parse LLM response (expecting JSON)
        const content = response.content[0];
        if (content.type !== "text") {
          throw new Error("Unexpected LLM response type");
        }

        let parsed: {
          agentType: AgentType;
          confidence: number;
          reasoning: string;
          keywords: string[];
        };

        try {
          // Extract JSON from response (handle markdown code blocks)
          const jsonMatch = content.text.match(/```json\s*([\s\S]*?)\s*```/) ||
                           content.text.match(/\{[\s\S]*\}/);
          if (!jsonMatch) {
            throw new Error("No JSON found in LLM response");
          }

          parsed = JSON.parse(jsonMatch[1] || jsonMatch[0]);
        } catch (error) {
          console.error(`[AgentDispatcher] Failed to parse LLM response: ${content.text}`);
          throw new Error("LLM response parsing failed");
        }

        return {
          agentType: parsed.agentType,
          confidence: parsed.confidence,
          keywords: parsed.keywords || [],
          method: "llm",
          reasoning: parsed.reasoning,
        };
      }

      /**
       * Builds classification prompt for LLM.
       *
       * @param description - Task description
       * @returns Prompt string
       */
      private buildClassificationPrompt(description: string): string {
        return `You are a task classifier for a code generation system. Classify the following task into one of these categories:

- "BE Boilerplate": Backend project setup (package.json, tsconfig.json, Express server)
- "FE Boilerplate": Frontend project setup (Vite, React, TypeScript)
- "BE CRUD APIs": Backend CRUD code generation (repositories, SQL queries, API endpoints)
- "FE CRUD Services": Frontend service code generation (API clients, TanStack Query hooks)
- "UI CRUD Pages": UI component generation (React forms, tables, pages)

Task: "${description}"

Respond with JSON in this format:
\`\`\`json
{
  "agentType": "BE Boilerplate" | "FE Boilerplate" | "BE CRUD APIs" | "FE CRUD Services" | "UI CRUD Pages",
  "confidence": 0.0-1.0,
  "reasoning": "Brief explanation of why this category fits",
  "keywords": ["extracted", "keywords", "from", "task"]
}
\`\`\``;
      }

      /**
       * Stores classification result in Convex.
       * Uses fire-and-forget pattern to avoid blocking.
       *
       * @param taskId - Optional task ID
       * @param classification - Classification result
       */
      private async storeClassification(
        taskId: string | undefined,
        classification: AgentClassification
      ): Promise<void> {
        if (!taskId) return;

        // Non-blocking Convex update
        convex.mutations.tasks.updateClassification({
          taskId,
          agentType: classification.agentType,
          confidence: classification.confidence,
          method: classification.method,
          keywords: classification.keywords,
          reasoning: classification.reasoning,
          timestamp: Date.now(),
        }).catch(err => {
          console.error(`[AgentDispatcher] Failed to store classification: ${err}`);
        });
      }

      /**
       * Gets all keyword patterns.
       * Useful for debugging and UI display.
       */
      getKeywordPatterns(): KeywordPatterns {
        return { ...this.keywordPatterns };
      }

      /**
       * Checks if LLM classifier is enabled.
       */
      isLLMEnabled(): boolean {
        return this.enableLLM && !!this.llmClient;
      }
    }
    ```

    Export from dispatcher/index.ts
  </action>
  <verify>grep -q "class AgentDispatcher" packages/agent-orchestrator/src/dispatcher/AgentDispatcher.ts</verify>
  <done>AgentDispatcher implemented with classifyTask, extractKeywords, llmClassify, storeClassification methods</done>
</task>

<task type="auto">
  <name>Create dispatcher barrel export</name>
  <files>packages/agent-orchestrator/src/dispatcher/index.ts</files>
  <action>
    Create dispatcher/index.ts barrel export:

    ```typescript
    // @convex-poc/agent-orchestrator/dispatcher - Agent dispatcher exports

    export { AgentDispatcher } from "./AgentDispatcher.js";
    export * from "./types.js";
    ```

    Update package.json exports:

    ```json
    "exports": {
      "./orchestrator": "./src/orchestrator/index.ts",
      "./planner": "./src/planner.ts",
      "./coder": "./src/coder.ts",
      "./reviewer": "./src/reviewer.ts",
      "./queue": "./src/queue/index.ts",
      "./agents": "./src/agents/index.ts",
      "./dispatcher": "./src/dispatcher/index.ts",
      "./types/queue": "./src/types/queue.ts"
    }
    ```
  </action>
  <verify>cat packages/agent-orchestrator/src/dispatcher/index.ts</verify>
  <done>Dispatcher module exported with AgentDispatcher and types</done>
</task>

<task type="auto">
  <name>Add Convex mutation for classification storage</name>
  <files>convex/tasks.ts</files>
  <action>
    Add updateClassification mutation to convex/tasks.ts:

    ```typescript
    import { mutation } from "./_generated/server";

    // Update task with classification result
    export const updateClassification = mutation({
      args: {
        taskId: v.id("tasks"),
        agentType: v.string(),
        confidence: v.number(),
        method: v.string(),
        keywords: v.array(v.string()),
        reasoning: v.optional(v.string()),
        timestamp: v.number(),
      },
      handler: async (ctx, args) => {
        const { taskId, ...classification } = args;

        // Store classification in task metadata (or add new field)
        await ctx.db.patch(taskId, {
          // Assuming tasks schema has metadata field
          // If not, this will need schema update
          metadata: {
            classification,
            classifiedAt: args.timestamp,
          },
        });
      },
    });
    ```

    Note: If tasks schema doesn't have metadata field, update convex/schema.ts to add:
    ```typescript
    tasks: defineTable({
      // ... existing fields
      classification: v.optional(v.object({
        agentType: v.string(),
        confidence: v.number(),
        method: v.string(),
        keywords: v.array(v.string()),
        reasoning: v.optional(v.string()),
      })),
      classifiedAt: v.optional(v.number()),
    })
    ```
  </action>
  <verify>grep -q "updateClassification" convex/tasks.ts</verify>
  <done>Convex mutation added for storing classification results</done>
</task>

</tasks>

<verification>
# Post-Execution Verification

## Build Check
- Run: `pnpm --filter @convex-poc/agent-orchestrator build`
- Expected: Clean compilation

## Classification Test
```bash
# Test keyword routing
node -e "
import { AgentDispatcher } from '@convex-poc/agent-orchestrator/dispatcher';

const dispatcher = new AgentDispatcher();

// Test keyword match
const result1 = await dispatcher.classifyTask('Create BE CRUD APIs for students table');
console.log('Keyword match:', result1.agentType, result1.confidence, result1.method);

// Test LLM fallback (if API key available)
const result2 = await dispatcher.classifyTask('Generate code for the school management system');
console.log('LLM classification:', result2.agentType, result2.confidence, result2.method);
"
```

## Keyword Patterns Check
- All 5 agent types have keyword patterns defined
- Patterns match ROADMAP.md keywords ("BE setup", "BE CRUD APIs", "FE setup", "FE CRUD services", "UI CRUD pages")
</verification>

<success_criteria>
1. AgentDispatcher routes tasks based on keyword matching (fast path)
2. LLM classifier handles ambiguous descriptions when keywords don't match
3. Classification results stored in Convex for debugging/transparency
4. Keyword patterns cover all 5 CRUD agent types
5. Default fallback (BE Boilerplate) when no match found
</success_criteria>

<output>
After completion, create `.planning/phases/15-agent-orchestration/15-05-SUMMARY.md`
</output>
