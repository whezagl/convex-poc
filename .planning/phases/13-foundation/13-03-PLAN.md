---
phase: 13-foundation
plan: 03
type: execute
wave: 3
depends_on: [13-02]
files_modified:
  - convex/schema.ts
  - convex/tasks.ts
  - convex/subtasks.ts
autonomous: true

must_haves:
  truths:
    - "Convex backend accepts connections and stores task/subtask/log documents"
    - "Schema is deployed to self-hosted Convex backend via npx convex dev"
    - "Indexes are defined for efficient Kanban queries"
  artifacts:
    - path: "convex/schema.ts"
      provides: "Convex schema with tasks and subtasks collections"
      contains: "defineSchema({ tasks: defineTable(...), subtasks: defineTable(...) })"
    - path: "convex/tasks.ts"
      provides: "Task CRUD functions (create, update, query)"
      exports: ["getTasks", "createTask", "updateTaskStatus"]
    - path: "convex/subtasks.ts"
      provides: "SubTask CRUD functions"
      exports: ["getSubTasks", "createSubTask", "updateSubTask"]
  key_links:
    - from: "packages/convex-client"
      to: "convex/tasks.ts, convex/subtasks.ts"
      via: "Convex client query/mutation calls"
      pattern: "ctx\\.db\\.(query|insert|update)"
---

<objective>
Extend Convex schema with tasks and subtasks collections, deploy to self-hosted backend.

Purpose: Add Kanban board data storage to Convex while preserving existing agentSessions and workflows collections. This enables task management and real-time sync across the Electron UI.
Output: Convex schema deployed with tasks, subtasks, and indexes for efficient queries.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/13-foundation/13-CONTEXT.md
@.planning/phases/13-foundation/13-RESEARCH.md

@convex/schema.ts
@.planning/phases/13-foundation/13-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Extend Convex schema with tasks and subtasks collections</name>
  <files>convex/schema.ts</files>
  <action>
    Extend existing convex/schema.ts with tasks and subtasks collections:

    ```typescript
    import { defineSchema, defineTable } from "convex/server";
    import { v } from "convex/values";

    export default defineSchema({
      // === EXISTING: Keep for agent orchestration ===
      agentSessions: defineTable({
        agentType: v.string(),
        status: v.string(),
        sessionId: v.optional(v.string()),
        input: v.string(),
        output: v.optional(v.string()),
        error: v.optional(v.string()),
        metadata: v.optional(v.object({
          workflowId: v.id("workflows"),
          startedAt: v.number(),
          completedAt: v.optional(v.number()),
        })),
      })
        .index("by_workflow", ["metadata.workflowId"])
        .index("by_status", ["status"]),

      workflows: defineTable({
        task: v.string(),
        status: v.string(),
        currentStep: v.string(),
        artifacts: v.array(v.string()),
        metadata: v.object({
          createdAt: v.number(),
          updatedAt: v.number(),
        }),
      })
        .index("by_status", ["status"]),

      // === NEW: For Kanban board task management ===
      tasks: defineTable({
        title: v.string(),
        description: v.optional(v.string()),
        status: v.union(
          v.literal("pending"),
          v.literal("running"),
          v.literal("paused"),
          v.literal("done"),
          v.literal("cancelled")
        ),
        priority: v.union(
          v.literal("low"),
          v.literal("medium"),
          v.literal("high")
        ),
        workspacePath: v.optional(v.string()),
        pauseReason: v.optional(v.union(
          v.literal("user"),
          v.literal("auto")
        )),
        // Sub-task IDs for parallel execution visualization
        subTaskIds: v.array(v.id("subtasks")),
        // Embedded logs for streaming (max size TBD, 1MB limit per Convex docs)
        logs: v.array(v.object({
          timestamp: v.number(),
          message: v.string(),
          level: v.union(v.literal("info"), v.literal("warning"), v.literal("error")),
          source: v.optional(v.string()),
        })),
      })
        .index("by_status", ["status"])
        .index("by_priority", ["priority"])
        .index("by_created_at", ["_creationTime"]),

      subtasks: defineTable({
        taskId: v.id("tasks"), // Reference to parent task
        title: v.string(),
        status: v.union(
          v.literal("pending"),
          v.literal("running"),
          v.literal("done"),
          v.literal("failed")
        ),
        agentType: v.string(), // "BE Boilerplate", "BE CRUD APIs", etc.
        stepNumber: v.number(),
        totalSteps: v.number(),
        // Embedded logs for sub-task streaming
        logs: v.array(v.object({
          timestamp: v.number(),
          message: v.string(),
          level: v.union(v.literal("info"), v.literal("warning"), v.literal("error")),
          source: v.optional(v.string()),
        })),
      })
        .index("by_task", ["taskId"])
        .index("by_status", ["status"])
        .index("by_created_at", ["_creationTime"]),
    });
    ```

    Key decisions:
    - Keep existing agentSessions and workflows (they serve different purpose - agent orchestration vs Kanban state)
    - Two separate collections (tasks + subtasks) per CONTEXT.md decision
    - Embedded logs in documents (simpler streaming, migrate to separate collection if size limits hit)
    - SubTask has taskId reference for "Sub-tasks" column queries
    - Task has subTaskIds array for expandable parent card visualization (Phase 18)
    - Indexes on status, priority, createdAt for efficient Kanban queries

    Do NOT use nested document structure - keep flat for simpler queries per RESEARCH.md.

    Note: Schema uses Convex's built-in v.union() validators directly - no imports from shared-types package needed. Task/SubTask types in shared-types are for TypeScript typing in client code.
  </action>
  <verify>
    - Run `npx convex dev` to start local development backend and deploy schema to self-hosted Convex backend
    - Check schema deployment: `npx convex dashboard` -> Schema tab
    - Verify all collections are visible: tasks, subtasks, agentSessions, workflows
    - Verify indexes exist: by_status, by_priority, by_task, by_created_at
  </verify>
  <done>
    Convex schema is extended with tasks and subtasks collections and deployed to self-hosted backend via npx convex dev
  </done>
</task>

<task type="auto">
  <name>Create Convex functions for task CRUD operations</name>
  <files>convex/tasks.ts</files>
  <action>
    Create convex/tasks.ts with CRUD functions following Convex patterns:

    ```typescript
    import { v } from "convex/values";
    import { mutation, query } from "./_generated/server";

    // Create a new task
    export const createTask = mutation({
      args: {
        title: v.string(),
        description: v.optional(v.string()),
        priority: v.union(
          v.literal("low"),
          v.literal("medium"),
          v.literal("high")
        ),
        workspacePath: v.optional(v.string()),
      },
      handler: async (ctx, args) => {
        const taskId = await ctx.db.insert("tasks", {
          title: args.title,
          description: args.description,
          status: "pending",
          priority: args.priority,
          workspacePath: args.workspacePath,
          subTaskIds: [],
          logs: [],
        });
        return taskId;
      },
    });

    // Get all tasks (for Kanban board)
    export const getTasks = query({
      handler: async (ctx) => {
        const tasks = await ctx.db.query("tasks").collect();
        return tasks;
      },
    });

    // Get tasks by status (for Kanban columns)
    export const getTasksByStatus = query({
      args: { status: v.string() },
      handler: async (ctx, args) => {
        const tasks = await ctx.db
          .query("tasks")
          .withIndex("by_status", (q) => q.eq("status", args.status))
          .collect();
        return tasks;
      },
    });

    // Update task status
    export const updateTaskStatus = mutation({
      args: {
        taskId: v.id("tasks"),
        status: v.union(
          v.literal("pending"),
          v.literal("running"),
          v.literal("paused"),
          v.literal("done"),
          v.literal("cancelled")
        ),
        pauseReason: v.optional(v.union(v.literal("user"), v.literal("auto"))),
      },
      handler: async (ctx, args) => {
        const { taskId, status, pauseReason } = args;
        await ctx.db.patch(taskId, {
          status,
          ...(pauseReason && { pauseReason }),
        });
      },
    });

    // Add log to task
    export const addTaskLog = mutation({
      args: {
        taskId: v.id("tasks"),
        message: v.string(),
        level: v.union(v.literal("info"), v.literal("warning"), v.literal("error")),
        source: v.optional(v.string()),
      },
      handler: async (ctx, args) => {
        const task = await ctx.db.get(args.taskId);
        if (!task) throw new Error("Task not found");

        const newLog = {
          timestamp: Date.now(),
          message: args.message,
          level: args.level,
          source: args.source,
        };

        await ctx.db.patch(args.taskId, {
          logs: [...task.logs, newLog],
        });
      },
    });

    // Get task by ID
    export const getTask = query({
      args: { taskId: v.id("tasks") },
      handler: async (ctx, args) => {
        const task = await ctx.db.get(args.taskId);
        return task;
      },
    });
    ```

    Follow RESEARCH.md Pattern 3 - Convex functions with proper validators.
  </action>
  <verify>
    - Run `npx convex dev` to ensure functions compile and deploy to self-hosted backend
    - Test function via dashboard: `npx convex dashboard` -> Functions -> createTask
    - Verify function is visible in Convex dashboard Functions tab
    - Test mutation with sample data
    - Verify Convex backend accepts connections: curl http://localhost:3210/ or visit http://localhost:6791 (dashboard)
  </verify>
  <done>
    Task CRUD functions are created and deployed to Convex backend, backend accepts connections
  </done>
</task>

<task type="auto">
  <name>Create Convex functions for subtask CRUD operations</name>
  <files>convex/subtasks.ts</files>
  <action>
    Create convex/subtasks.ts with CRUD functions:

    ```typescript
    import { v } from "convex/values";
    import { mutation, query } from "./_generated/server";

    // Create a new subtask
    export const createSubTask = mutation({
      args: {
        taskId: v.id("tasks"),
        title: v.string(),
        agentType: v.string(),
        totalSteps: v.number(),
      },
      handler: async (ctx, args) => {
        const subtaskId = await ctx.db.insert("subtasks", {
          taskId: args.taskId,
          title: args.title,
          status: "pending",
          agentType: args.agentType,
          stepNumber: 1,
          totalSteps: args.totalSteps,
          logs: [],
        });

        // Add subtask ID to parent task
        const task = await ctx.db.get(args.taskId);
        if (task) {
          await ctx.db.patch(args.taskId, {
            subTaskIds: [...task.subTaskIds, subtaskId],
          });
        }

        return subtaskId;
      },
    });

    // Get subtasks by task ID (for "Sub-tasks" column)
    export const getSubTasksByTask = query({
      args: { taskId: v.id("tasks") },
      handler: async (ctx, args) => {
        const subtasks = await ctx.db
          .query("subtasks")
          .withIndex("by_task", (q) => q.eq("taskId", args.taskId))
          .collect();
        return subtasks;
      },
    });

    // Update subtask status
    export const updateSubTaskStatus = mutation({
      args: {
        subtaskId: v.id("subtasks"),
        status: v.union(
          v.literal("pending"),
          v.literal("running"),
          v.literal("done"),
          v.literal("failed")
        ),
      },
      handler: async (ctx, args) => {
        await ctx.db.patch(args.subtaskId, {
          status: args.status,
        });
      },
    });

    // Update subtask progress (stepNumber)
    export const updateSubTaskProgress = mutation({
      args: {
        subtaskId: v.id("subtasks"),
        stepNumber: v.number(),
      },
      handler: async (ctx, args) => {
        await ctx.db.patch(args.subtaskId, {
          stepNumber: args.stepNumber,
        });
      },
    });

    // Add log to subtask
    export const addSubTaskLog = mutation({
      args: {
        subtaskId: v.id("subtasks"),
        message: v.string(),
        level: v.union(v.literal("info"), v.literal("warning"), v.literal("error")),
        source: v.optional(v.string()),
      },
      handler: async (ctx, args) => {
        const subtask = await ctx.db.get(args.subtaskId);
        if (!subtask) throw new Error("SubTask not found");

        const newLog = {
          timestamp: Date.now(),
          message: args.message,
          level: args.level,
          source: args.source,
        };

        await ctx.db.patch(args.subtaskId, {
          logs: [...subtask.logs, newLog],
        });
      },
    });

    // Get subtask by ID
    export const getSubTask = query({
      args: { subtaskId: v.id("subtasks") },
      handler: async (ctx, args) => {
        const subtask = await ctx.db.get(args.subtaskId);
        return subtask;
      },
    });
    ```

    Key decisions:
    - createSubTask adds subtaskId to parent task's subTaskIds array
    - getSubTasksByTask uses by_task index for efficient queries
    - addSubTaskLog appends to logs array (same pattern as tasks)
  </action>
  <verify>
    - Run `npx convex dev` to ensure functions compile
    - Test function via dashboard: `npx convex dashboard` -> Functions -> createSubTask
    - Verify subtask ID is added to parent task's subTaskIds array
    - Test getSubTasksByTask query returns correct subtasks
  </verify>
  <done>
    SubTask CRUD functions are created and deployable to Convex backend
  </done>
</task>

</tasks>

<verification>
Overall phase checks:
- `npx convex dev` starts without errors and deploys schema to self-hosted backend
- Convex backend accepts connections: curl http://localhost:3210/ returns response or dashboard at http://localhost:6791 loads
- Schema is deployed: tasks, subtasks, agentSessions, workflows collections visible
- Indexes exist: by_status, by_priority, by_task, by_created_at
- Functions are visible in Convex dashboard
- Can create task via dashboard function test
- Can create subtask via dashboard function test
- Subtask ID is added to parent task's subTaskIds array
</verification>

<success_criteria>
1. Convex schema extended with tasks and subtasks collections
2. Schema is deployed to self-hosted Convex backend via npx convex dev
3. Convex backend accepts connections on http://localhost:3210
4. Indexes defined for efficient Kanban queries (status, priority, createdAt)
5. Task and SubTask CRUD functions are deployed
6. Existing agentSessions and workflows collections preserved
</success_criteria>

<output>
After completion, create `.planning/phases/13-foundation/13-03-SUMMARY.md`
</output>
