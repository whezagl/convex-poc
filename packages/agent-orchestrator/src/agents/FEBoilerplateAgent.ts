// @convex-poc/agent-orchestrator/agents/FEBoilerplateAgent - Frontend boilerplate agent

import { join, dirname } from "path";
import { promises as fs } from "fs";
import { BaseCRUDAgent } from "./BaseCRUDAgent.js";
import type { CRUDAgentConfig, TableDefinition } from "./types.js";

/**
 * FEBoilerplateAgent generates frontend project structure.
 *
 * Spawns 1 sub-task that generates:
 * - package.json with Vite 6, React 19, TypeScript
 * - tsconfig.json with ES2020 target
 * - vite.config.ts with React plugin
 * - src/main.tsx with React root
 * - src/App.tsx with basic routing
 * - src/index.css with basic styles
 * - index.html with Vite entry
 * - README.md with setup instructions
 * - .gitignore with Vite exclusions
 *
 * Templates: .templates/boilerplate/fe/* (from Phase 14-04)
 */
export class FEBoilerplateAgent extends BaseCRUDAgent {
  constructor(config: CRUDAgentConfig) {
    super(config);
  }

  /**
   * Selects the appropriate template for frontend boilerplate.
   * Templates from Phase 14-04:
   * - package.json.hbs
   * - tsconfig.json.hbs
   * - vite.config.ts.hbs
   * - src/main.tsx.hbs
   * - src/App.tsx.hbs
   * - src/index.css.hbs
   * - index.html.hbs
   * - README.md.hbs
   * - .gitignore.hbs
   */
  protected selectTemplate(): string {
    return "boilerplate/fe";
  }

  /**
   * Prepares template variables for frontend boilerplate.
   *
   * Variables for Phase 14-04 templates:
   * - projectName: From workspace path or default
   * - description: Optional project description
   * - Dependencies are hardcoded in templates (Vite 6, React 19, React Router 7, TanStack Query)
   */
  protected async prepareTemplateVariables(): Promise<Record<string, unknown>> {
    const { workspacePath } = this.config;

    const projectName = workspacePath.split("/").pop() || "frontend-project";

    return {
      projectName,
      description: "Frontend UI generated by AI Agents POC",
    };
  }

  /**
   * Returns output path for generated frontend files.
   */
  protected getOutputPath(): string {
    return this.config.workspacePath;
  }

  /**
   * Overrides execute to handle multi-file boilerplate generation.
   * FE boilerplate generates 8 files from templates.
   */
  async execute(): Promise<void> {
    const { totalSteps } = this.config;

    try {
      // Step 1: Load templates (all 8 files)
      await this.updateProgress(1, "Loading frontend boilerplate templates");

      const templateFiles = [
        "package.json.hbs",
        "tsconfig.json.hbs",
        "vite.config.ts.hbs",
        "src/main.tsx.hbs",
        "src/App.tsx.hbs",
        "src/index.css.hbs",
        "index.html.hbs",
        "README.md.hbs",
        ".gitignore.hbs",
      ];

      const templates = await Promise.all(
        templateFiles.map(file =>
          this.templateEngine.load(`boilerplate/fe/${file}`)
        )
      );

      // Step 2: Prepare variables
      await this.updateProgress(2, "Preparing frontend project variables");
      const variables = await this.prepareTemplateVariables();

      // Step 3: Generate code
      await this.updateProgress(3, "Generating frontend project files");

      const generatedFiles = templates.map((template, index) => ({
        template,
        outputPath: join(
          this.config.workspacePath,
          templateFiles[index].replace(".hbs", "")
        ),
        variables,
      }));

      // Step 4: Write files
      await this.updateProgress(4, "Writing frontend project files");
      for (const { template, outputPath, variables } of generatedFiles) {
        const code = template(variables);
        await this.writeFileWithLock(outputPath, code);
      }

      // Step 5: Complete
      await this.updateProgress(totalSteps, "Frontend boilerplate generated", "done");

    } catch (error) {
      await this.handleExecutionError("frontend boilerplate", error);
    }
  }

  /**
   * Writes file with locking for custom output paths.
   */
  protected async writeFileWithLock(
    outputPath: string,
    content: string
  ): Promise<void> {
    await fs.mkdir(dirname(outputPath), { recursive: true });

    await this.lockManager.withLock(outputPath, async () => {
      await fs.writeFile(outputPath, content, "utf-8");
    });
  }
}
