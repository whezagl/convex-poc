// @convex-poc/agent-orchestrator/agents/BEBoilerplateAgent - Backend boilerplate agent

import { join } from "path";
import { promises as fs } from "fs";
import type { AgentType } from "@convex-poc/shared-types/agent";
import { BaseCRUDAgent, type CRUDAgentConfig, type TableDefinition } from "./BaseCRUDAgent.js";

/**
 * BEBoilerplateAgent generates backend project structure.
 *
 * Spawns 1 sub-task that generates:
 * - package.json with Express 5.0.0, Zod 4.0.0, pg 8.13.0
 * - tsconfig.json with ES2022 target
 * - biome.json with 2-space indent, 80 char width
 * - README.md with setup instructions
 * - .gitignore with Node.js exclusions
 * - src/index.ts with Express server setup
 *
 * Templates: .templates/boilerplate/be/* (from Phase 14-03)
 */
export class BEBoilerplateAgent extends BaseCRUDAgent {
  constructor(config: CRUDAgentConfig) {
    super(config);
  }

  /**
   * Selects the appropriate template for backend boilerplate.
   * Templates from Phase 14-03:
   * - package.json.hbs
   * - tsconfig.json.hbs
   * - biome.json.hbs
   * - README.md.hbs
   * - .gitignore.hbs
   * - src/index.ts.hbs
   */
  protected selectTemplate(): string {
    // Returns base directory - agent will iterate through template files
    return "boilerplate/be";
  }

  /**
   * Prepares template variables for backend boilerplate.
   *
   * Variables for Phase 14-03 templates:
   * - projectName: From workspace path or default
   * - description: Optional project description
   * - Dependencies are hardcoded in templates (Express 5.0.0, Zod 4.0.0, pg 8.13.0)
   */
  protected async prepareTemplateVariables(): Promise<Record<string, unknown>> {
    const { workspacePath } = this.config;

    // Extract project name from workspace path
    const projectName = workspacePath.split("/").pop() || "backend-project";

    return {
      projectName,
      description: "Backend API generated by AI Agents POC",
    };
  }

  /**
   * Returns output path for generated backend files.
   *
   * Files are written to:
   * - workspacePath/package.json
   * - workspacePath/tsconfig.json
   * - workspacePath/biome.json
   * - workspacePath/README.md
   * - workspacePath/.gitignore
   * - workspacePath/src/index.ts
   */
  protected getOutputPath(): string {
    // Base output directory - individual files handled by execute override
    return this.config.workspacePath;
  }

  /**
   * Overrides execute to handle multi-file boilerplate generation.
   * BE boilerplate generates 6 files from templates.
   */
  async execute(): Promise<void> {
    const { totalSteps } = this.config;

    try {
      // Step 1: Load templates (all 6 files)
      await this.updateProgress(1, "Loading backend boilerplate templates");

      const templateFiles = [
        "package.json.hbs",
        "tsconfig.json.hbs",
        "biome.json.hbs",
        "README.md.hbs",
        ".gitignore.hbs",
        "src/index.ts.hbs",
      ];

      const templates = await Promise.all(
        templateFiles.map(file =>
          this.templateEngine.load(`boilerplate/be/${file}`)
        )
      );

      // Step 2: Prepare variables
      await this.updateProgress(2, "Preparing backend project variables");
      const variables = await this.prepareTemplateVariables();

      // Step 3: Generate code for all files
      await this.updateProgress(3, "Generating backend project files");
      const generatedFiles = templates.map((template, index) => ({
        template,
        outputPath: join(
          this.config.workspacePath,
          templateFiles[index].replace(".hbs", "")
        ),
        variables,
      }));

      // Step 4: Write files with locking
      await this.updateProgress(4, "Writing backend project files");
      for (const { template, outputPath, variables } of generatedFiles) {
        const code = template(variables);
        await this.writeWithLock(undefined, code, outputPath);
      }

      // Step 5: Complete
      await this.updateProgress(totalSteps, "Backend boilerplate generated", "done");

    } catch (error) {
      await this.handleExecutionError("backend boilerplate", error);
    }
  }

  /**
   * Overridden writeWithLock to support custom output paths.
   */
  protected async writeWithLock(
    _table: TableDefinition | undefined,
    content: string,
    customPath?: string
  ): Promise<void> {
    const outputPath = customPath || this.getOutputPath(_table);

    // Ensure parent directory exists
    await fs.mkdir(dirname(outputPath), { recursive: true });

    // Write with lock
    await this.lockManager.withLock(outputPath, async () => {
      await fs.writeFile(outputPath, content, "utf-8");
    });
  }
}
